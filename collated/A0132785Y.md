# A0132785Y
###### src\doordonote\common\Task.java
``` java
	public int compareTo(Task task){

		// if both tasks are floating tasks
		if (task.getEndDate() == null && getEndDate() == null) {
			return getDescription().compareTo(task.getDescription());
		} 
		// if task is a deadline or event, and the other is floating
		else if (task.getEndDate() != null && getEndDate() == null) {
			return 1;
		} 
		// if task is floating and the other is a deadline or event
		else if (task.getEndDate() == null && getEndDate() != null) {
			return -1;
		}
		// if task is an event and the other is a deadline
		else if (task.getStartDate() != null && getStartDate() == null) {
			// if task is a single day event
			if (task.getStartDate().getDate() == task.getEndDate().getDate()) {
				return getEndDate().compareTo(task.getEndDate());
			}
			// if task is a multiple day event
			else {
				return -1;
			}
		} 
		// if task is a deadline and the other is an event
		else if (task.getStartDate() == null && getStartDate() != null) {
			// if other task is a single day event
			if (getStartDate().getDate() == getEndDate().getDate()) {
				return getEndDate().compareTo(task.getEndDate());
			}
			// if other task is a multiple day event
			else {
				return 1;
			}
		} 
		// if both tasks are deadlines
		else if (task.getStartDate() == null && getStartDate() == null) {
			return getEndDate().compareTo(task.getEndDate());
		} 
		// both tasks are events: if task is a single day event and other
		// is a multiple day event
		else if (task.getStartDate().getDate() == task.getEndDate().getDate()
				&& getStartDate().getDate() != getEndDate().getDate()) {
			return 1;
		} 
		// if task is a multiple day event and other is a single day event
		else if (task.getStartDate().getDate() != task.getEndDate().getDate()
				&& getStartDate().getDate() == getEndDate().getDate()) {
			return -1;
		} 
		// if both tasks are single day events
		else if (task.getStartDate().getDate() == task.getEndDate().getDate()
				&& getStartDate().getDate() == getEndDate().getDate()) {
			return getStartDate().compareTo(task.getStartDate());
		} 
		// if both tasks are multiple day events
		else if (task.getStartDate().getDate() != task.getEndDate().getDate()
				&& getStartDate().getDate() != getEndDate().getDate()) {
			return getStartDate().compareTo(task.getStartDate());
		} else {
			return 0;
		}
	}


```
###### src\doordonote\storage\TaskWriter.java
``` java
		private boolean checkClashCondition(Task originalTask, Task toCheckTask){
			
			// conditions for clashing
			boolean condition1 = toCheckTask.getStartDate().after(originalTask.getStartDate()) 
					&& toCheckTask.getStartDate().before(originalTask.getEndDate());
			boolean condition2 = toCheckTask.getEndDate().after(originalTask.getStartDate()) 
					&& toCheckTask.getEndDate().before(originalTask.getEndDate());
			boolean condition3 = originalTask.getStartDate().after(toCheckTask.getStartDate()) 
					&& originalTask.getEndDate().before(toCheckTask.getEndDate());
			boolean condition4 = originalTask.getStartDate().equals(toCheckTask.getStartDate());
			boolean condition5 = originalTask.getEndDate().equals(toCheckTask.getEndDate());
			
			if(condition1 || condition2 || condition3 || condition4 || condition5) {
				return true;
			} else {
				return false;
			}
		}

```
###### src\doordonote\ui\DateUtil.java
``` java
package doordonote.ui;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

import doordonote.common.Task;

public class DateUtil {
	
	/** String objects for days of the week */
	private static final String DAY_SUN = "Sunday";
	private static final String DAY_MON = "Monday";
	private static final String DAY_TUES = "Tuesday";
	private static final String DAY_WED = "Wednesday";
	private static final String DAY_THURS = "Thursday";
	private static final String DAY_FRI = "Friday";
	private static final String DAY_SAT = "Saturday";
	
	/** String objects for months of the year */
	private static final String MONTH_JAN = "Jan";
	private static final String MONTH_FEB = "Feb";
	private static final String MONTH_MAR = "Mar";
	private static final String MONTH_APR = "Apr";
	private static final String MONTH_MAY = "May";
	private static final String MONTH_JUN = "Jun";
	private static final String MONTH_JUL = "Jul";
	private static final String MONTH_AUG = "Aug";
	private static final String MONTH_SEPT = "Sept";
	private static final String MONTH_OCT = "Oct";
	private static final String MONTH_NOV = "Nov";
	private static final String MONTH_DEC = "Dec";
	
	/** String objects for time period conventions */
	private static final String TIME_AM = "am";
	private static final String TIME_PM = "pm";
	
	/** Messages displayed for assertion fails */
	private static final String MESSAGE_ASSERT_WRONG_DAY = "Day cannot be outside the range 1-7";
	private static final String MESSAGE_ASSERT_WRONG_MONTH = "Month cannot be outside the range 0-11";
	private static final String MESSAGE_ASSERT_NEGATIVE_TIME = "Time cannot be negative";
	private static final String MESSAGE_ASSERT_WRONG_MINUTES = "Minutes cannot exceed 59";
	private static final String MESSAGE_ASSERT_WRONG_HOUR = "Hour cannot exceed 23";
	
	/**
	 * Converts a Date object to a Calendar object and returns it, 
	 * since some of Date's API has been deprecated
	 *  
	 * @param cal         Date object for the date of a task
	 * 
	 * @return            Calendar object for the Date object passed
	 */
	public static Calendar dateToCalendar(Date date) {
		
		Calendar cal = Calendar.getInstance();
		cal.setTime(date);
		
		return cal;
	}
	
	/**
	 * Returns a String for the day of the Calendar object
	 * passed for the task (Mon, Tues etc), since 
	 * Calendar only gives an int value for day
	 *  
	 * @param cal         Calendar object for the date of a task
	 * 
	 * @return            String for the day of the cal object
	 */
	public static String getDay(Calendar cal) {
		
		String day = null;
		
		switch(cal.get(Calendar.DAY_OF_WEEK)) {
		  case 1 : {
			  day = DAY_SUN;
			  break;
		  }
		  case 2 : {
			  day = DAY_MON;
				break;
		  }
		  case 3 : {
			  day = DAY_TUES;
			  break;
		  }
		  case 4 : {
			  day = DAY_WED;
			  break;
		  }
		  case 5 : {
			  day = DAY_THURS;
			  break;
		  }
		  case 6 : {
			  day = DAY_FRI;
			  break;
		  }
		  case 7 : {
			  day = DAY_SAT;
			  break;
		  }
		  default : {
			  assert false: MESSAGE_ASSERT_WRONG_DAY; 
		  }
		}

		return day;
	}
	
	/**
	 * Returns a String for the month of the Calendar object
	 * passed for the task (January, February etc), since 
	 * Calendar only gives an int value for month
	 *  
	 * @param cal         Calendar object for the date of a task
	 * 
	 * @return            String for the month of the cal object
	 */
	public static String getMonth(Calendar cal) {
		
		String month = null;
		
		switch(cal.get(Calendar.MONTH)) {
		  case 0 : {
			  month = MONTH_JAN;
			  break;
		  }
		  case 1 : {
			  month = MONTH_FEB;
			  break;
		  }
	
		  case 2 : {
			  month = MONTH_MAR;
			  break;
		  }
		  case 3 : {
			  month = MONTH_APR;
			  break;
		  }
		  case 4 : {
			  month = MONTH_MAY;
			  break;
		  }
		  case 5 : {
			  month = MONTH_JUN;
			  break;
		  }
		  case 6 : {
			  month = MONTH_JUL;
			  break;
		  }
		  case 7 : {
			  month = MONTH_AUG;
			  break;
		  }
		  case 8 : {
			  month = MONTH_SEPT;
			  break;
		  }
		  case 9 : {
			  month = MONTH_OCT;
			  break;
		  }
		  case 10: {
			  month = MONTH_NOV;
			  break;
		  }
		  case 11 : {
			  month = MONTH_DEC;
			  break;
		  }
		  default : {
			  assert false: MESSAGE_ASSERT_WRONG_MONTH; 
		  }
		}

		return month;
	}
	
	/**
	 * Returns a String for the minutes of the Calendar
	 * object passed for the task (in mm format, null for 0 minutes)
	 * since Calendar only gives an int value
	 *  
	 * @param cal         Calendar object for the date of a task
	 * 
	 * @return            String for the minutes of the cal object
	 */
	public static String getMinutes(Calendar cal) {
		
		String minutesString;
		int minutes = cal.get(Calendar.MINUTE);
        
		// Single digit minutes
		if (minutes < 10) {
			if(minutes == 0) {
				minutesString = null;
			}
			else {
				// Minutes cannot be negative
				assert minutes > 0: MESSAGE_ASSERT_NEGATIVE_TIME;
				minutesString = "0" + minutes;
			}
		}
		// Double digit minutes
		else {
			// Minutes cannot be greater than 59 (60 becomes 0)
			assert minutes < 60: MESSAGE_ASSERT_WRONG_MINUTES;
			minutesString = "" + minutes;
		}

		return minutesString;        
	}
	
	/**
	 * Returns a String for the time (hour, minutes and am/pm) of the Calendar
	 * object passed for the task 
	 *  
	 * @param cal         Calendar object for the date of a task
	 * 
	 * @return            String for the time of the cal object
	 */
	public static String getTime(Calendar cal) {
		
		String time;
		String minutes = getMinutes(cal);
		int hour = cal.get(Calendar.HOUR_OF_DAY);
        
		// for pm time period (and conversion to 12-hour clock)
		if (hour > 12) {
			// hour cannot be greater than 23 (24 becomes 0)
			assert hour < 24: MESSAGE_ASSERT_WRONG_HOUR;
			if (minutes != null) {
				time = (hour - 12) + ":" + minutes + TIME_PM;
			}
			else {
				// if minutes are zero, they are simply omitted from string
				time = (hour - 12) + TIME_PM;
			}
		}
		// for am time period
		else if (hour < 12){
			if (minutes != null) {
				if (hour == 0) {

					time = hour + 12 + ":" + minutes + TIME_AM;
				}
				else{
					// hour cannot be negative
					assert hour > 0: MESSAGE_ASSERT_NEGATIVE_TIME;
					time = hour + ":" + minutes + TIME_AM;
				}
			}
			else {
				if (hour == 0) {
					time = hour + 12 + TIME_AM;
				}
				else {
					assert hour > 0: MESSAGE_ASSERT_NEGATIVE_TIME;
					time = hour + TIME_AM;
				}
			}
		}
		// if hour is 12 then pm time period but no conversion needed
		else {
			if (minutes != null) {
				time = hour + ":" + minutes + TIME_PM;
			}
			else {
				time = hour + TIME_PM;
			}
		}

		return time;  

	}
	
	/**
	 * Returns a boolean value after checking if the current day (today)  
	 * is same as the day of the Date object passed
	 *  
	 * @param date        Date object of a task
	 * 
	 * @return            boolean value returning true if day of Date passed
	 *                    is today, and false otherwise
	 */
	public static boolean checkForToday(Date date) {
		
		SimpleDateFormat dateFormat = new SimpleDateFormat("MM/dd/yyyy");
		Date today = new Date();
		boolean isToday = dateFormat.format(date).equals(dateFormat.format(today));
		
		return isToday;
	}
	
	/**
	 * Returns a boolean value after checking if the current time falls 
	 * after the end time for a task i.e. the task is overdue 
	 *  
	 * @param date        end date Date object of a task
	 * 
	 * @return            boolean value returning true if task is overdue,
	 *                    and false otherwise
	 */
	public static boolean checkForOverdue(Date date) {
		
		Date today = new Date();
		boolean isOverdue = date.before(today);
		
		return isOverdue;

	}
	
	/**
	 * Returns a boolean value after checking if the current time falls 
	 * between the start and end time for a task i.e. the task is ongoing 
	 *  
	 * @param start       start date Date object of a task
	 * @param end       end date Date object of a task
	 * 
	 * @return            boolean value returning true if task is ongoing,
	 *                    and false otherwise
	 */
	public static boolean checkForOngoing(Date start, Date end) {
		
		Date today = new Date();
		boolean isOngoing = (!today.before(start)) && (!today.after(end));
		
		return isOngoing;
	}
	
	/**
	 * Returns a boolean value after checking if the two Tasks
	 * passed are on the same day or not 
	 *  
	 * @param task1       Task object 1 to be checked for same day with task2
	 * @param task2       Task object 2 to be checked for same day with task1
	 * 
	 * @return            boolean value returning true if both Tasks are NOT
	 *                    on the same day, and false otherwise
	 */
	public static boolean checkForSameDay(Task task1, Task task2) {
		
		Calendar calEnd1 = dateToCalendar(task1.getEndDate());
		String month1 = getMonth(calEnd1);
		int date1 = calEnd1.get(Calendar.DAY_OF_MONTH);
		
		Calendar calEnd2 = dateToCalendar(task2.getEndDate());
		String month2 = getMonth(calEnd2);
		int date2 = calEnd2.get(Calendar.DAY_OF_MONTH);
		
		boolean isNotSameDate = date1 != date2 || !(month1.equals(month2));
		
		return isNotSameDate;
		
	}
	
	/**
	 * Returns a boolean value after checking if the event Task 
	 * passed is a multiple day event or not 
	 *  
	 * @param task        EventTask object to be checked for multiple day event 
	 * @param formatter   SimpleDateFormat object to format Date objects
	 * 
	 * @return            boolean value returning true if task is multiple day
	 *                    event, false otherwise
	 */
	public static boolean checkIfMultipleDayEvent(Task task, SimpleDateFormat formatter) {
		
		String startDate = formatter.format(task.getStartDate());
		String endDate = formatter.format(task.getEndDate());

		boolean isMultipleDayEvent = !(startDate.equals(endDate));
		
		return isMultipleDayEvent;
	}
	
}
```
###### src\doordonote\ui\UI.java
``` java
package doordonote.ui;

import doordonote.common.Task;
import doordonote.logic.Logic;
import doordonote.logic.UIToLogic;
import doordonote.logic.UIState;
import doordonote.ui.DateUtil;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.text.SimpleDateFormat;
import java.lang.StringBuilder;
import java.util.logging.*;

import org.apache.commons.lang.WordUtils;

import javafx.animation.FillTransition;
import javafx.animation.SequentialTransition;
import javafx.animation.Timeline;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Interpolator;
import javafx.stage.Stage;
import javafx.util.Duration;
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextField;
import javafx.scene.control.ScrollPane.ScrollBarPolicy;
import javafx.scene.effect.DropShadow;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.scene.text.TextAlignment;
import javafx.scene.shape.Shape;

/**
 *
 * @author Priyanka
 */
public class UI extends Application {
    
	/** String objects for state of helpBox from UIState */
	private static final String HELP = "help";
	private static final String HELP_ADD = "add";
	private static final String HELP_DELETE = "delete";
	private static final String HELP_UPDATE = "update";
	private static final String HELP_FIND = "find";
	private static final String HELP_FINISH = "finish";
	private static final String HELP_SAVE = "save";
	private static final String HELP_RESTORE = "restore";
	private static final String HELP_READFROM = "readfrom";
	private static final String HELP_VIEW = "view";
    
	/** String objects for commands */
	private static final String COMMAND_HOME = "home";
	private static final String COMMAND_DISPLAY_FINISH = "view finished";
	private static final String COMMAND_DISPLAY_DELETE = "view deleted";
	private static final String COMMAND_UNDO = "undo";
	private static final String COMMAND_REDO = "redo";
    
	/** String objects for different messages displayed to the user */
	private static final String MESSAGE_WELCOME = "Welcome to DoOrDoNote! "
			+ "Type in \"help\" for all the help you need!";
	private static final String MESSAGE_COMMAND_TABLE = "Table for Commands: ";
	private static final String MESSAGE_SHORTCUT_TABLE = "Table for Keyboard Shortcuts: ";
	private static final String MESSAGE_COLOUR_TABLE = "Table for Colour Coding of Tasks: ";
	private static final String MESSAGE_HELP = "Hello! "
			+ "This is the page to provide you with all the help you need for DoOrDoNote";
	private static final String MESSAGE_HELP_COMMAND = "Hello! Here is a table of the commands "
			+ "you can use for ";
	private static final String MESSAGE_NO_INPUT = "Try typing one of our commands. "
			+ "For help, just type \"help\"!";
    
	/** String objects for titles displayed */
	private static final String TITLE_APP = "DoOrDoNote";
	private static final String TITLE_HOME = "Home";
	private static final String TITLE_HELP = "Help!";
	private static final String TITLE_FLOATING = "Floating Tasks";
	private static final String TITLE_EVENTS = "Events Spanning Tasks";
    
	/** String objects for text for labels */
	private static final String LABEL_OK = " OK ";
	private static final String LABEL_COMMAND = "Command:";
    
	/** String objects for types of tasks */
	private static final String TYPE_EVENT = "EVENT_TASK";
	private static final String TYPE_DEADLINE = "DEADLINE_TASK";
	private static final String TYPE_FLOATING = "FLOATING_TASK";
    
	/** String objects for different fonts */
	private static final String FONT_CALIBRI = "Calibri";
	private static final String FONT_TAHOMA = "Tahoma";
	private static final String FONT_AHARONI = "Aharoni";
	
	/** String objects for logging warning messages */
	private static final String EXECUTION_ERROR_LOGGING = "processing execution error";
	private static final String FILE_ERROR_LOGGING = "processing file error";
	
	/** double value for the scroll change during up/down keys navigation */
	private static final double SCROLL_INCREMENT = 0.2;
    
	/** Text object for the feedback area containing feedback to be displayed */
	private static Text output = new Text(MESSAGE_WELCOME);
	
	/** Text object for the header area containing header to be displayed */
	private static Text title = new Text(TITLE_HOME);
	
	/** BorderPane object for the Scene to be displayed in the main display*/
	private static BorderPane border = new BorderPane();
	
	/** Scene object for the Stage to be displayed in the main display */
	private static Scene scene = new Scene(border);
    
	/** integer for the Task ID of the tasks displayed */
	private static int count;
    
	/** Logic object to which input is to be passed and data for display is to be retrieved */
	private static UIToLogic logic = null;
	
	/** Obtains a suitable logger for class UI */
	private static Logger logger = Logger.getLogger("UI");
    
	/** Constructor for UI */
	public UI() {
		logic = new Logic();
		count = 1;
	}

	/**
	 * The main entry point for all JavaFX applications. 
	 * The start method is invoked once the application is opened by the user, 
	 * and after the system is ready for the application to begin running
	 *
	 * @param primaryStage     the primary stage for this application, 
	 *                         onto which the application scene can be set. 
	 */
	@Override
	public void start(Stage primaryStage) {
		
		UIState state = new UIState();
		
		border.setBottom(addBottomArea());
		border.setCenter(addMainDisplay(0, state.getDisplayType()));
		border.setTop(addHeader(state.getDisplayType()));

		primaryStage.setScene(scene);
		primaryStage.setTitle(TITLE_APP);
		primaryStage.getIcons().add(new Image("icon1.jpg"));
		primaryStage.show();
		// ensures application enters full screen by default
		primaryStage.setMaximized(true);

	}
    
	/**
	 * Return a vertical box containing elements of the bottom 
	 * section of the display
	 *
	 * @return     vertical box VBox.
	 */
	public static VBox addBottomArea() {
		
		VBox vBox = new VBox();
		vBox.setPadding(new Insets(10, 12, 10, 12));
		vBox.setSpacing(5);
		vBox.setStyle("-fx-background-color: #383737;");

		HBox hBox = new HBox();
		hBox.setStyle("-fx-background-color: #F0F0F0;"); 
		hBox.setAlignment(Pos.CENTER);
		hBox.setPadding(new Insets(5, 5, 5, 5));
		
		output.setFont(Font.font(FONT_CALIBRI, FontWeight.NORMAL, 16));
		output.setFill(Color.web("#00811C"));
		
		hBox.getChildren().add(output);

		vBox.getChildren().addAll(hBox, addCommandArea());
		vBox.setAlignment(Pos.CENTER);
		
		return vBox;

	}
	
	/**
	 * Return a horizontal box containing elements of the  
	 * command section of the display
	 *
	 * @return     horizontal box HBox.
	 */
	public static HBox addCommandArea() {

		HBox hBox = new HBox();
		hBox.setPadding(new Insets(5, 12, 5, 12));
		hBox.setSpacing(10);

		Label command = new Label(LABEL_COMMAND);
		command.setFont(Font.font(FONT_CALIBRI, FontWeight.NORMAL, 16));
		command.setTextFill(Color.web("#FFFFFF"));
		
		TextField commandBox = new TextField();
		commandBox.setPrefWidth(500);

		handleUserInput(commandBox);

		hBox.getChildren().addAll(command, commandBox);
		hBox.setAlignment(Pos.CENTER);

		return hBox;
	}
	
	/**
	 * Handles user input given in commandBox.
	 * Passes the user input to Logic and
	 * displays feedback returned as output.
	 * Also calls Logic's getState() to get UIState
	 * object for information regarding display
	 *
	 * @param commandBox  TextField where user can enter input      
	 */
	public static void handleUserInput(TextField commandBox) {

		commandBox.setOnKeyPressed(new EventHandler<KeyEvent>() {
			String feedback;

			@Override
			public void handle(KeyEvent ke) {
				if (ke.getCode().equals(KeyCode.ENTER)) {
					if (commandBox.getText() != null && ! commandBox.getText().trim().isEmpty()) {
						try { 
							feedback = logic.parseAndExecuteCommand(commandBox.getText());
							
							UIState state = logic.getState();

							if (state.getHelpBox() == null) {
								handleNonHelpCommand(feedback, state, commandBox);
							} else {
								handleHelpCommand(feedback, state, commandBox);
							}
						} catch (Exception e) {
							handleExecutionException(e.getMessage());
						}
					} 
					// if user presses enter without giving a command
					else {
						feedback = MESSAGE_NO_INPUT;
						output.setText(feedback);
						output.setFill(Color.web("#00811C"));
					}
				}
                
				// keyboard shortcut for home
				if (ke.getCode().equals(KeyCode.ESCAPE)) {
					try {
						feedback = logic.parseAndExecuteCommand(COMMAND_HOME);
						UIState state = logic.getState();

						handleNonHelpCommand(feedback, state, commandBox);
					} catch (Exception e) {
						handleExecutionException(e.getMessage());
					}
				}
                
				// keyboard shortcut for undo
				if (ke.getCode().equals(KeyCode.Z) && ke.isShortcutDown()) {
					try {
						feedback = logic.parseAndExecuteCommand(COMMAND_UNDO);
						UIState state = logic.getState();
						
						handleNonHelpCommand(feedback, state, commandBox);
					} catch (Exception e) {
						handleExecutionException(e.getMessage());
					}
				}
                
				// keyboard shortcut for redo
				if (ke.getCode().equals(KeyCode.Y) && ke.isShortcutDown()) {
					try {
						feedback = logic.parseAndExecuteCommand(COMMAND_REDO);
						UIState state = logic.getState();
						
						handleNonHelpCommand(feedback, state, commandBox);
					} catch (Exception e) {
						handleExecutionException(e.getMessage());
					}
				}
                
				// keyboard shortcut for view deleted
				if (ke.getCode().equals(KeyCode.D) && ke.isShortcutDown()) {
					try {
						feedback = logic.parseAndExecuteCommand(COMMAND_DISPLAY_DELETE);
						UIState state = logic.getState();
						
						handleNonHelpCommand(feedback, state, commandBox);
					} catch (Exception e) {
						handleExecutionException(e.getMessage());
					}
				}
                
				// keyboard shortcut for view finished
				if (ke.getCode().equals(KeyCode.F) && ke.isShortcutDown()) {
					try {
						feedback = logic.parseAndExecuteCommand(COMMAND_DISPLAY_FINISH);
						UIState state = logic.getState();
						
						handleNonHelpCommand(feedback, state, commandBox);
					} catch (Exception e) {
						handleExecutionException(e.getMessage());
					}
				}
                
				// keyboard shortcut for help
				if (ke.getCode().equals(KeyCode.H) && ke.isShortcutDown()) {
					try {
						feedback = logic.parseAndExecuteCommand(HELP);
						UIState state = logic.getState();
						
						handleHelpCommand(feedback, state, commandBox);
					} catch (Exception e) {
						handleExecutionException(e.getMessage());
					}
				}

			}
		});
	}
    
	/**
	 * Handles exceptions thrown from logic while parsing and executing user
	 * command 
	 *
	 * @param feedback  String message for the exception to be displayed as  
	 *                  feedback in the Text object output
	 */
	public static void handleExecutionException(String feedback) {
		
		//log a message at WARNING level
		logger.log(Level.WARNING, EXECUTION_ERROR_LOGGING, feedback);
		
		UIState state = logic.getState();
		
		border.setCenter(addMainDisplay(0, state.getDisplayType()));
		
		output.setText(feedback);
		// sets the colour of feedback displayed as output as red
		output.setFill(Color.web("#F20505"));
		
	}
	
	/**
	 * Handles the display of UI after user-entered non-help commands 
	 * by gathering information from Logic's UIState
	 *
	 * @param feedback     String message to be displayed as output after
	 *                     successful execution of command
	 * @param state        UIState object giving information about the display
	 *                     (title, list type, Task ID for highlighting, input Box)
	 * @param commandBox   TextField object where for the user input, to be 
	 *                     manipulated according to UIState
	 */
	public static void handleNonHelpCommand(String feedback, UIState state, 
			                                TextField commandBox) {
		
		output.setText(feedback);
		output.setFill(Color.web("#00811C"));

		border.setCenter(addMainDisplay(state.getIdNewTask() + 1, state.getDisplayType()));
		border.setTop(addHeader(state.getDisplayType()));
		
		if (state.getTitle() != null) {
			title.setText(state.getTitle());
		}
		if (state.getInputBox() == null || state.getInputBox() == "") {
			commandBox.clear();
		} else {
			commandBox.setText(state.getInputBox());
			// to position the caret at the end of the line of text
			commandBox.positionCaret(state.getInputBox().length() + 1);
		}
		
	}
	
	/**
	 * Handles the display of UI after user-entered help command 
	 * by gathering information from Logic's UIState
	 *
	 * @param feedback     String message to be displayed as output after
	 *                     successful execution of command
	 * @param state        UIState object giving information about the type 
	 *                     of help display
	 * @param commandBox   TextField object for the user input, to be 
	 *                     cleared after help command
	 */
	public static void handleHelpCommand(String feedback, UIState state, 
			                             TextField commandBox) {
		
		output.setText(feedback);
		output.setFill(Color.web("#00811C"));

		Stage helpStage;
		switch (state.getHelpBox()) {
		case HELP_ADD: {
			// Fallthrough
		}
		case HELP_DELETE: {
			// Fallthrough
		}
		case HELP_FIND: {
			// Fallthrough
		}
		case HELP_FINISH: {
			// Fallthrough
		}
		case HELP_READFROM: {
			// Fallthrough
		}
		case HELP_SAVE: {
			// Fallthrough
		}
		case HELP_RESTORE: {
			// Fallthrough
		}
		case HELP_VIEW: {
			// Fallthrough
		}
		case HELP_UPDATE: {
			helpStage = createHelpCommandWindow(state.getHelpBox());
			break;
		}
		default: {
			helpStage = createHelpWindow();
			break;
		}
		}

		helpStage.show();
		
		// closes help window if user presses Enter or Esc
		helpStage.addEventFilter(KeyEvent.KEY_PRESSED, new EventHandler<KeyEvent>() {
			@Override
			public void handle(KeyEvent evt) {
				if (evt.getCode().equals(KeyCode.ESCAPE)
						|| evt.getCode().equals(KeyCode.ENTER)) {
					helpStage.close();
				}
			}
		});
		
		commandBox.clear();
	}
	
	/**
	 * Returns the Stage for the Help window 
	 * box with all useful info for the user.
	 *  
	 * @return            Help window Stage
	 */
	public static Stage createHelpWindow() {
		
		Stage stage = new Stage();

		HBox hBox1 = new HBox();
		hBox1.setSpacing(15);
		hBox1.setAlignment(Pos.CENTER);
		
		Image image1 = new Image("question_mark.png");
		ImageView imv1 = new ImageView(image1);
		imv1.setFitWidth(30);
		imv1.setPreserveRatio(true);
		imv1.setSmooth(true);
		imv1.setCache(true);
		
		Text helpHeader = new Text(MESSAGE_HELP);
		helpHeader.setFont(Font.font(FONT_CALIBRI, FontWeight.BOLD, 18));
		helpHeader.setFill(Color.web("#00143E")); // #00143E
		
		hBox1.getChildren().addAll(helpHeader, imv1);
		
		HBox hBox2 = new HBox();
		hBox2.setSpacing(15);
		hBox2.setAlignment(Pos.CENTER);
		
		// for the table of commands
		VBox vBox1 = new VBox();
	    vBox1.setSpacing(5);
	    vBox1.setAlignment(Pos.TOP_CENTER);
        
		Text commandHeader = new Text(MESSAGE_COMMAND_TABLE);
		commandHeader.setFont(Font.font(FONT_CALIBRI, FontWeight.NORMAL, 15));
		commandHeader.setFill(Color.web("#00143E"));

		Image image2 = new Image("help.png");
		ImageView imv2 = new ImageView(image2);
		imv2.setFitWidth(650);
		imv2.setPreserveRatio(true);
		imv2.setSmooth(true);
		imv2.setCache(true);
		
		vBox1.getChildren().addAll(commandHeader, imv2);
		
		// for the table of shortcuts
		VBox vBox2_1 = new VBox();
		vBox2_1.setSpacing(5);
		vBox2_1.setAlignment(Pos.TOP_CENTER);
		
		Text shortcutHeader = new Text(MESSAGE_SHORTCUT_TABLE);
		shortcutHeader.setFont(Font.font(FONT_CALIBRI, FontWeight.NORMAL, 15));
		shortcutHeader.setFill(Color.web("#00143E"));
		
		Image image3 = new Image("helpshortcut.png");
		ImageView imv3 = new ImageView(image3);
		imv3.setFitWidth(550);
		imv3.setPreserveRatio(true);
		imv3.setSmooth(true);
		imv3.setCache(true);
		
		// for the table of colour codes
		vBox2_1.getChildren().addAll(shortcutHeader, imv3);
		
		VBox vBox2_2 = new VBox();
		vBox2_2.setSpacing(5);
		vBox2_2.setAlignment(Pos.TOP_CENTER);
		
		Text colourCodeHeader = new Text(MESSAGE_COLOUR_TABLE);
		colourCodeHeader.setFont(Font.font(FONT_CALIBRI, FontWeight.NORMAL, 15));
		colourCodeHeader.setFill(Color.web("#00143E"));
		
		Image image4 = new Image("helpcolour.png");
		ImageView imv4 = new ImageView(image4);
		imv4.setFitWidth(550);
		imv4.setPreserveRatio(true);
		imv4.setSmooth(true);
		imv4.setCache(true);

		vBox2_2.getChildren().addAll(colourCodeHeader, imv4);
		
		Button button = new Button(LABEL_OK);
        
		VBox vBox2 = new VBox();
		vBox2.setSpacing(15);
		vBox2.setAlignment(Pos.TOP_CENTER);
		vBox2.getChildren().addAll(vBox2_1, vBox2_2, button);
		
		hBox2.getChildren().addAll(vBox1, vBox2);

		VBox vBox = new VBox();
		vBox.setPadding(new Insets(10, 20, 0, 20));
		vBox.setSpacing(10);
		vBox.getChildren().addAll(hBox1, hBox2);
		vBox.setAlignment(Pos.TOP_CENTER);
		vBox.setStyle("-fx-background-color: #eff4ff;");
		
		Scene sc = new Scene(vBox);

		stage.setTitle(TITLE_HELP);
		stage.getIcons().add(image1);
		stage.setScene(sc);
        
		// if pressed, button OK closes the window
		button.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent e) {
				stage.close();
			}
		});

		return stage;
	}
    
	/**
	 * Returns the Stage for the Help window 
	 * box for a particular command type
	 * with all useful info about that command 
	 * type for the user.
	 *  
	 * @param commandType String for the type of command for which 
	 *                    help is to be displayed            
	 * @return            Help window Stage for specific command type
	 */
	public static Stage createHelpCommandWindow(String commandType) {
		
		Stage stage = new Stage();
		
		HBox hBox = new HBox();
		hBox.setSpacing(15);
		hBox.setAlignment(Pos.CENTER);
		
		Image image1 = new Image("question_mark.png");
		ImageView imv1 = new ImageView(image1);
		imv1.setFitWidth(30);
		imv1.setPreserveRatio(true);
		imv1.setSmooth(true);
		imv1.setCache(true);

		Text helpHeader = new Text(MESSAGE_HELP_COMMAND + 
				commandType.toUpperCase() + ":");
		helpHeader.setFont(Font.font(FONT_CALIBRI, FontWeight.BOLD, 18));
		helpHeader.setFill(Color.web("#00143E")); // #00143E
		
		hBox.getChildren().addAll(helpHeader, imv1);

		Image image2 = getTableImage(commandType);

		ImageView imv2 = new ImageView(image2);
		imv2.setFitWidth(700);
		imv2.setPreserveRatio(true);
		imv2.setSmooth(true);
		imv2.setCache(true);

		Button button = new Button(LABEL_OK);

		VBox vBox = new VBox();
		vBox.setPadding(new Insets(15, 30, 10, 30));
		vBox.setSpacing(10);
		vBox.getChildren().addAll(hBox, imv2, button);
		vBox.setAlignment(Pos.TOP_CENTER);
		vBox.setStyle("-fx-background-color: #eff4ff;");
		
		Scene sc = new Scene(vBox);

		stage.setTitle(TITLE_HELP);
		stage.getIcons().add(image1);
		stage.setScene(sc);

		button.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent e) {
				stage.close();
			}
		});

		return stage;
	}
	
	/**
	 * Returns the Image object for the Help window 
	 * box displaying help table for a particular
	 * command type with all useful info about that 
	 * command type for the user.
	 *  
	 * @param commandType String for the type of command for which 
	 *                    image is to be returned            
	 * @return            Image object for specific command type
	 */
	public static Image getTableImage(String commandType) {
		
		Image image;
		
		switch (commandType) {
		case HELP_ADD: {
			image = new Image("helpadd.png");
			break;
		}
		case HELP_DELETE: {
			image = new Image("helpdelete.jpg");
			break;
		}
		case HELP_FIND: {
			image = new Image("helpfind.png");
			break;
		}
		case HELP_FINISH: {
			image = new Image("helpfinish.jpg");
			break;
		}
		case HELP_READFROM: {
			image = new Image("helpreadfrom.png");
			break;
		}
		case HELP_SAVE: {
			image = new Image("helpsave.png");
			break;
		}
		case HELP_RESTORE: {
			image = new Image("helprestore.jpg");
			break;
		}
		case HELP_UPDATE: {
			image = new Image("helpupdate.png");
			break;
		}
		case HELP_VIEW: {
			image = new Image("helpview.png");
			break;
		}
		default: {
			// main help box with all commands as default
			image = new Image("help.png");
		}
		}
		
		return image;
	}
	
	/**
	 * Returns the horizontal box for the main window 
	 * displaying all the tasks inside their boxes
	 *  
	 * @param taskId      id of the task to be highlighted after update or add command
	 * @param listType    type of task lists to be displayed (home, deleted, finished)
	 * @return            horizontal box HBox for main display
	 */
	public static HBox addMainDisplay(int taskId, doordonote.logic.UIState.ListType listType) {
		
		HBox main = new HBox();

		main.setPadding(new Insets(40, 25, 30, 25));
		main.setSpacing(40);
		main.setStyle("-fx-background-image: url('whitee.png');" + "-fx-background-size: 100% 100%; "
				+ "-fx-background-repeat: no-repeat;");


		SimpleDateFormat formatter = new SimpleDateFormat("MM/dd/yyyy");
		List<Task> taskList;
		
		try {
			taskList = logic.getTasks();
		}
		catch (Exception e) {
			//log a message at WARNING level
			logger.log(Level.WARNING, FILE_ERROR_LOGGING, e);
			
			/* if exception thrown by logic, displays exception 
			 * message as feedback in red and initialises taskList
			 * as an empty List 
			 */
			taskList = new ArrayList<Task>();
			output.setText(e.getMessage());
			output.setFill(Color.web("#F20505"));
			
		}

		boolean haveEventsSpanningDays = checkForEventsSpanningDays(taskList, formatter);
		boolean isHome = listType.equals(doordonote.logic.UIState.ListType.NORMAL);

		count = 1;

		VBox singleDayBox = new VBox();
		singleDayBox.setPrefWidth(500);
		singleDayBox.setStyle("-fx-background-color: #E1F5EF;");

		VBox singleDayTasks = displaySingleDayTasks(taskId, isHome, taskList, formatter);
		ScrollPane scroll1 = createScroll();
		scroll1.setContent(singleDayTasks);
		singleDayBox.getChildren().addAll(scroll1);

		VBox multipleDayBox = new VBox();
		multipleDayBox.setPrefWidth(500);
		multipleDayBox.setStyle("-fx-background-color: #FFF3F3;");

		if (haveEventsSpanningDays == true) {

			ScrollPane scroll3 = createScroll();
			VBox eventsSpanningDays = displayEventsSpanningDays(taskId, isHome, taskList, formatter);

			scroll3.setContent(eventsSpanningDays);
			multipleDayBox.getChildren().addAll(scroll3);
		}
        
		VBox floatingBox = new VBox();
		floatingBox.setPrefWidth(500);
		floatingBox.setStyle("-fx-background-color: #F9FFC6;");

		ScrollPane scroll2 = createScroll();
		VBox floatingTasks = displayFloatingTasks(taskId, taskList);
		scroll2.setContent(floatingTasks);
		floatingBox.getChildren().addAll(scroll2);

		if (haveEventsSpanningDays == true) {
			VBox leftSideBoxes = new VBox();
			leftSideBoxes.setSpacing(10);
			multipleDayBox.setPrefHeight(235);
			floatingBox.setPrefHeight(235);
			leftSideBoxes.getChildren().addAll(multipleDayBox, floatingBox);
			main.getChildren().addAll(singleDayBox, leftSideBoxes);
		} else {
			main.getChildren().addAll(singleDayBox, floatingBox);
		}

		main.setAlignment(Pos.TOP_CENTER);

		return main;

	}
	
	/**
	 * Customizes and returns a ScrollPane object for a
	 * task list box
	 *  
	 * @return     customized ScrollPane object for VBox
	 */
	public static ScrollPane createScroll() {
		
		ScrollPane scroll = new ScrollPane();
		VBox.setVgrow(scroll, Priority.ALWAYS);
		scroll.setFitToHeight(true);
		scroll.setFitToWidth(true);
		scroll.setPrefSize(115, 150);
		scroll.setHbarPolicy(ScrollBarPolicy.NEVER);
		scroll.setVbarPolicy(ScrollBarPolicy.AS_NEEDED);
		
		// for scrolling using up/down arrow keys
		scene.addEventFilter(KeyEvent.KEY_PRESSED, new EventHandler<KeyEvent>() {
			@Override
			public void handle(KeyEvent evt) {
				if (evt.getCode().equals(KeyCode.UP)) {
					if (scroll.getVvalue() > scroll.getVmin()) {
						scroll.setVvalue(scroll.getVvalue() - SCROLL_INCREMENT);
					}
				}
				if (evt.getCode().equals(KeyCode.DOWN)) {
					if (scroll.getVvalue() < scroll.getVmax()) {
						scroll.setVvalue(scroll.getVvalue() + SCROLL_INCREMENT);
					}
				}
			}
		});
		
		return scroll;
		
	}
    
	/**
	 * Returns the boolean value corresponding to the check for events spanning days
	 * in the task list
	 *  
	 * @param taskList    the list of all tasks to be displayed
	 * @param formatter   SimpleDateFormat formatter for formatting dates
	 * @return            boolean value to check for events spanning days
	 */
	public static boolean checkForEventsSpanningDays(List<Task> taskList, SimpleDateFormat formatter) {
		boolean haveEventsSpanningDays = false;

		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getType().equals(TYPE_EVENT)) {

				String startDate = formatter.format(taskList.get(i).getStartDate());
				String endDate = formatter.format(taskList.get(i).getEndDate());

				if (!(startDate.equals(endDate))) {
					haveEventsSpanningDays = true;
					break;
				}
			}
		}

		return haveEventsSpanningDays;
	}

	/**
	 * Returns the vertical box for the display 
	 * of dated tasks NOT spanning multiple days
	 *  
	 * @param taskId      id of the task to be highlighted after update or add command
	 * @param isHome      boolean value: true if display is of home type, else false
	 *                    lets method know if tasks are to be colour coded
	 * @param taskList    list of all tasks to be displayed
	 * @param formatter   SimpleDateFormat object for formatting of task dates
	 *                
	 * @return            vertical box VBox for display of single day tasks
	 */
	public static VBox displaySingleDayTasks(int taskId, boolean isHome, List<Task> taskList,
			SimpleDateFormat formatter) {
		
		VBox vBox = new VBox();
		vBox.setAlignment(Pos.TOP_LEFT);
		vBox.setPadding(new Insets(18, 18, 18, 18));
		vBox.setSpacing(15);
		vBox.setPrefWidth(500);
		vBox.setStyle("-fx-background-color: #E1F5EF;");

		boolean haveEventsOrDeadlines = true;
		boolean haveSameDate = true;

		for (int i = 0; i < taskList.size(); i++) {
			if (!(taskList.get(i).getType().equals(TYPE_FLOATING))) {
				if (taskList.get(i).getType().equals(TYPE_EVENT)) {
					// if task encountered is multiple day event, doesn't display
					if (DateUtil.checkIfMultipleDayEvent(taskList.get(i), formatter)) {
						continue;
					}
				}

				String dateString = getDateToBeDisplayedString(taskList.get(i));
				Text taskDate = new Text(dateString);
				taskDate.setFont(Font.font(FONT_TAHOMA, FontWeight.BOLD, 18));
				taskDate.setTextAlignment(TextAlignment.CENTER);
				taskDate.setFill(Color.web("#0C1847"));

				HBox dates = new HBox();
				dates.setAlignment(Pos.TOP_CENTER);
				dates.getChildren().add(taskDate);

				Text taskDesc;
				String task;
				if (taskList.get(i).getType().equals(TYPE_DEADLINE)) {
					task = getDeadlineString(taskList.get(i));
					// uses apache's WordUtils class to wrap text for long tasks
					taskDesc = new Text(WordUtils.wrap(task, 62, "\n", true));
					
					FillTransition colour;
					
					// if task is overdue and display type is home
					if (DateUtil.checkForOverdue(taskList.get(i).getEndDate()) && isHome) {
						taskDesc.setFill(Color.RED);
						colour = changeColour(taskDesc, Color.RED);
					} else {
						colour = changeColour(taskDesc, Color.BLACK);
					}
					
					// if count i.e. Task ID of task corresponds to value of taskId passed, task is highlighted 
					if (count == taskId + 1) {
						Timeline blinker = createBlinker(taskDesc);
						SequentialTransition blink = 
								new SequentialTransition(taskDesc, blinker, colour);

						blink.play();
					}
				} else {
					task = getSingleDayEventString(taskList.get(i));
					taskDesc = new Text(WordUtils.wrap(task, 62, "\n", true));
					
					FillTransition colour;
					if (DateUtil.checkForOngoing(taskList.get(i).getStartDate(), 
							taskList.get(i).getEndDate()) && isHome) {
						taskDesc.setFill(Color.web("#0F6F00"));
						colour = changeColour(taskDesc, Color.web("#0F6F00"));
					} else if (DateUtil.checkForOverdue(taskList.get(i).getEndDate()) && isHome) {
						taskDesc.setFill(Color.RED);
						colour = changeColour(taskDesc, Color.RED);
					} else {
						colour = changeColour(taskDesc, Color.BLACK);
					}
					
					if (count == taskId + 1) {
						Timeline blinker = createBlinker(taskDesc);
						SequentialTransition blink = new SequentialTransition(taskDesc, blinker, colour);

						blink.play();
					}
				}

				taskDesc.setFont(Font.font(FONT_CALIBRI, FontWeight.NORMAL, 16));
				vBox.getChildren().addAll(dates, taskDesc);
				for (int j = i + 1; j < taskList.size(); j++) {
					haveSameDate = true;
					if (!(taskList.get(j).getType().equals(TYPE_FLOATING))) {
						if (taskList.get(j).getType().equals(TYPE_EVENT)) {
							if (DateUtil.checkIfMultipleDayEvent(taskList.get(j), formatter)) {
								continue;
							}
						}

						if (DateUtil.checkForSameDay(taskList.get(i), taskList.get(j))) {
							haveSameDate = false;
						}
						// if same date, task is displayed under that day
						else {
							Text taskDesc2;
							
							FillTransition colour;
							if (taskList.get(j).getType().equals(TYPE_DEADLINE)) {
								task = getDeadlineString(taskList.get(j));
								taskDesc2 = new Text(WordUtils.wrap(task, 62, "\n", true));

								if (DateUtil.checkForOverdue(taskList.get(j).getEndDate()) 
										&& isHome) {
									taskDesc2.setFill(Color.RED);
									colour = changeColour(taskDesc2, Color.RED);
								} else {
									colour = changeColour(taskDesc2, Color.BLACK);
								}
							} else {
								task = getSingleDayEventString(taskList.get(j));
								taskDesc2 = new Text(WordUtils.wrap(task, 62, "\n", true));
								if (DateUtil.checkForOngoing(taskList.get(j).getStartDate(),
										taskList.get(j).getEndDate()) && isHome) {
									taskDesc2.setFill(Color.web("#0F6F00"));
									colour = changeColour(taskDesc2, Color.web("#0F6F00"));
								} else if (DateUtil.checkForOverdue(taskList.get(j).getEndDate()) 
										&& isHome) {
									taskDesc2.setFill(Color.RED);
									colour = changeColour(taskDesc2, Color.RED);
								} else {
									colour = changeColour(taskDesc2, Color.BLACK);
								}
							}
							
							taskDesc2.setFont(Font.font(FONT_CALIBRI, FontWeight.NORMAL, 16));
							
							if (count == taskId + 1) {
								Timeline blinker = createBlinker(taskDesc2);
								SequentialTransition blink = 
										new SequentialTransition(taskDesc2, blinker, colour);

								blink.play();
							}
							vBox.getChildren().addAll(taskDesc2);
							i++;
						}
					}
					// if floating task encountered, doesn't display
					else {
						haveEventsOrDeadlines = false;
					}
					if (haveEventsOrDeadlines == false || haveSameDate == false) {
						break;
					}
				}
			} else {
				haveEventsOrDeadlines = false;
			}

			if (haveEventsOrDeadlines == false) {
				break;
			}

		}

		return vBox;
	}
	
	/**
	 * Returns the String for the Date to be displayed in the single day events
	 * box (today(if true), day, date and month)
	 *  
	 * @param task      Task whose date is to be displayed
	 *                
	 * @return          String for date of task
	 */
	public static String getDateToBeDisplayedString(Task task) {

		Calendar calEnd = DateUtil.dateToCalendar(task.getEndDate());
		String day = DateUtil.getDay(calEnd);
		String month = DateUtil.getMonth(calEnd);
		int date = calEnd.get(Calendar.DAY_OF_MONTH);
		
		String dateString;
		if (DateUtil.checkForToday(task.getEndDate())) {
			dateString = "Today, " + day + ", " + date + " " + month;
		} else {
			dateString = day + ", " + date + " " + month;
		}
		
		return dateString;
	}
	
	/**
	 * Returns the customized String for the deadline task to be displayed 
	 * in the single day events box (end time and description)
	 *  
	 * @param task      DeadlineTask which is to be displayed as String
	 *                
	 * @return          String for deadline task
	 */
	public static String getDeadlineString(Task task) {
		
		Calendar calEnd = DateUtil.dateToCalendar(task.getEndDate());
		String timeEnd = DateUtil.getTime(calEnd);
		
		String taskString = count++ + ". " + "[by " + timeEnd + "] " + task.getDescription();
		
		return taskString;
		
	}
	
	/**
	 * Returns the customized String for the event task to be displayed 
	 * in the single day events box (start time-end time and description)
	 *  
	 * @param task      EventTask which is to be displayed as String
	 *                
	 * @return          String for single day event task
	 */
	public static String getSingleDayEventString(Task task) {
		
		Calendar calStart = DateUtil.dateToCalendar(task.getStartDate());
		String timeStart = DateUtil.getTime(calStart);
		
		Calendar calEnd = DateUtil.dateToCalendar(task.getEndDate());
		String timeEnd = DateUtil.getTime(calEnd);
		
		String taskString = count++ + ". " + "[" + timeStart + "-" + timeEnd + "] " 
		                    + task.getDescription();
		
		return taskString;
	}

	/**
	 * Returns the vertical box for the display 
	 * of event tasks spanning multiple days
	 *  
	 * @param taskId      id of the task to be highlighted after update or add command
	 * @param isHome      boolean value: true if display is of home type, else false
	 *                    lets method know if tasks are to be colour coded
	 * @param taskList    list of all tasks to be displayed
	 * @param formatter   SimpleDateFormat object for formatting of task dates
	 *                
	 * @return            vertical box VBox for display of multiple day events
	 */
	public static VBox displayEventsSpanningDays(int taskId, boolean isHome, 
			List<Task> taskList, SimpleDateFormat formatter) {

		VBox vBox = new VBox();
		vBox.setAlignment(Pos.TOP_LEFT);
		vBox.setPadding(new Insets(18, 18, 18, 18));
		vBox.setSpacing(15);
		vBox.setPrefWidth(500);
		vBox.setStyle("-fx-background-color: #FFF3F3;");

		HBox events = new HBox();
		events.setAlignment(Pos.TOP_CENTER);
		Text eventsHeader = new Text(TITLE_EVENTS);
		eventsHeader.setFont(Font.font(FONT_TAHOMA, FontWeight.BOLD, 20));
		eventsHeader.setTextAlignment(TextAlignment.CENTER);
		eventsHeader.setFill(Color.web("#560000"));
		events.getChildren().add(eventsHeader);
		vBox.getChildren().add(events);

		for (int i = 0; i < taskList.size(); i++) {

			if (taskList.get(i).getType().equals(TYPE_EVENT)) {
				String start = formatter.format(taskList.get(i).getStartDate());
				String end = formatter.format(taskList.get(i).getEndDate());

				if (!(start.equals(end))) {
					String eventTask = getMultipleDayEventString(taskList.get(i));
					Text eventDisplay = new Text(WordUtils.wrap(eventTask, 62, "\n", true));
					eventDisplay.setFont(Font.font(FONT_CALIBRI, FontWeight.NORMAL, 16));
					
					FillTransition colour;
					
					if (DateUtil.checkForOverdue(taskList.get(i).getEndDate()) && isHome) {
						eventDisplay.setFill(Color.RED);
						colour = changeColour(eventDisplay, Color.RED);
					} else if (DateUtil.checkForOngoing(taskList.get(i).getStartDate(), 
							taskList.get(i).getEndDate()) && isHome) {
						eventDisplay.setFill(Color.web("#0F6F00"));
						colour = changeColour(eventDisplay, Color.web("#0F6F00"));
					} else {
						colour = changeColour(eventDisplay, Color.BLACK);
					}
					
					if (count == taskId + 1) {
						Timeline blinker = createBlinker(eventDisplay);

						SequentialTransition blink = 
								new SequentialTransition(eventDisplay, blinker, colour);

						blink.play();
					}
					
					vBox.getChildren().add(eventDisplay);
				}
			}
		}

		return vBox;
	}
	
	/**
	 * Returns the customized String for the event task to be displayed 
	 * in the multiple day events box (start date and time-end date and time 
	 * and description)
	 *  
	 * @param task      EventTask which is to be displayed as String
	 *                
	 * @return          String for multiple day event task
	 */
	public static String getMultipleDayEventString(Task task) {
		
		Calendar calStart = DateUtil.dateToCalendar(task.getStartDate());
		String startDay = DateUtil.getDay(calStart);
		String startMonth = DateUtil.getMonth(calStart);
		String startTime = DateUtil.getTime(calStart);
		int startDate = calStart.get(Calendar.DAY_OF_MONTH);

		Calendar calEnd = DateUtil.dateToCalendar(task.getEndDate());
		String endDay = DateUtil.getDay(calEnd);
		String endMonth = DateUtil.getMonth(calEnd);
		String endTime = DateUtil.getTime(calEnd);
		int endDate = calEnd.get(Calendar.DAY_OF_MONTH);

		String taskString = count++ + ". " + "[" + startDay + ", " + startDate + " " 
		                     + startMonth + ", " + startTime + " - " + endDay + 
		                     ", " + endDate + " " + endMonth + ", " + endTime + "] "
				             + task.getDescription();
		
		return taskString;
	}
    
	/**
	 * Returns the vertical box for the display 
	 * of floating tasks
	 *  
	 * @param taskId      id of the task to be highlighted after update or add command
	 * @param taskList    list of all tasks to be displayed
	 *                
	 * @return            vertical box VBox for display of floating tasks
	 */
	public static VBox displayFloatingTasks(int taskId, List<Task> taskList) {
		
		VBox vBox = new VBox();
		vBox.setAlignment(Pos.TOP_LEFT);
		vBox.setPadding(new Insets(18, 18, 18, 18));
		vBox.setSpacing(15);
		vBox.setPrefWidth(500);
		vBox.setStyle("-fx-background-color: #F9FFC6;");

		boolean haveFloatingTasks = false;

		HBox floating = new HBox();
		floating.setAlignment(Pos.TOP_CENTER);
		Text floatingHeader = new Text(TITLE_FLOATING);
		floatingHeader.setFont(Font.font(FONT_TAHOMA, FontWeight.BOLD, 20));
		floatingHeader.setTextAlignment(TextAlignment.CENTER);
		floatingHeader.setFill(Color.web("#3C220A"));
		floating.getChildren().add(floatingHeader);
		vBox.getChildren().add(floating);

		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getType().equals(TYPE_FLOATING)) {
				haveFloatingTasks = true;
				String floatingTask = (count++ + ". " + taskList.get(i).getDescription());

				Text floatingDisplay = new Text(WordUtils.wrap(floatingTask, 62, "\n", true));
				floatingDisplay.setFont(Font.font(FONT_CALIBRI, FontWeight.NORMAL, 16));
				
				if (count == taskId + 1) {
					Timeline blinker = createBlinker(floatingDisplay);
					FillTransition colour = changeColour(floatingDisplay, Color.BLACK);
					SequentialTransition blink = new SequentialTransition(floatingDisplay, blinker, colour);

					blink.play();
				}
				vBox.getChildren().add(floatingDisplay);
			}
		}

		if (haveFloatingTasks == false) {
			Text noFloatingTasks = new Text("*none*");
			noFloatingTasks.setFont(Font.font(FONT_CALIBRI, FontWeight.NORMAL, 16));
			vBox.getChildren().add(noFloatingTasks);
		}

		return vBox;
	}
    
	/**
	 * Return a horizontal box customizing of the top
	 * (header) section of the display according to listType
	 * (normal, finished, deleted)
	 *
	 * @param listType      type of list to be displayed as instructed by 
	 *                      Logic's UIState       
	 * @return              horizontal box HBox for the header area
	 */
	public static HBox addHeader(doordonote.logic.UIState.ListType listType) {
		
		HBox hBox = new HBox();
		hBox.setPadding(new Insets(20, 25, 20, 25));
		if (listType.equals(doordonote.logic.UIState.ListType.NORMAL)) {
			hBox.setStyle("-fx-background-color: #0D0D0D;");
		} else if (listType.equals(doordonote.logic.UIState.ListType.FINISHED)) {
			hBox.setStyle("-fx-background-color: #000E54;");
		} else {
			hBox.setStyle("-fx-background-color: #560202;");
		}

		setTitleEffects();

		hBox.getChildren().add(title);
		hBox.setAlignment(Pos.CENTER);

		return hBox;
	}
	
	/**
	 * Sets shadow effects for the title Text object of the header area 
	 * of the display
	 * 
	 */
	public static void setTitleEffects() {
		
		DropShadow shadow = new DropShadow();
		shadow.setOffsetY(4.0f);
		shadow.setColor(Color.color(0.4f, 0.4f, 0.4f));

		title.setFont(Font.font(FONT_AHARONI, FontWeight.BOLD, 30));
		title.setFill(Color.WHITE);
		title.setEffect(shadow);
		title.setCache(true);
		title.setX(10.0f);
		title.setY(270.0f);
	}

	/**
	 * Creates a Timeline object for the blinker, to be played 
	 * when a task is to be higlighted
	 * 
	 * @param node       The node to which the blinking effect is to be added
	 *                   In this class, text object
	 * 
	 * @return Timeline  Timeline object for the blinker
	 */
	public static Timeline createBlinker(Node node) {
		
		KeyValue keyValue1 = new KeyValue(node.opacityProperty(), 1, Interpolator.DISCRETE);
		KeyValue keyValue2 = new KeyValue(node.opacityProperty(), 0, Interpolator.DISCRETE);
		KeyValue keyValue3 = new KeyValue(node.opacityProperty(), 1, Interpolator.DISCRETE);
		
		KeyFrame keyFrame1 = new KeyFrame(Duration.seconds(0), keyValue1);
		KeyFrame keyFrame2 = new KeyFrame(Duration.seconds(0.25), keyValue2);
		KeyFrame keyFrame3 = new KeyFrame(Duration.seconds(0.5), keyValue3);
		
		Timeline blink = new Timeline(keyFrame1, keyFrame2, keyFrame3);
		
		blink.setCycleCount(3);

		return blink;
	}
    
	/**
	 * Creates a FillTransition object for changing colour purposes, 
	 * to be played when a task is to be higlighted
	 * 
	 * @param shape            the shape whose colour is to be changed
	 *                         In this class, a Text object
	 * @param                  the final colour to be set to shape
	 *                         after colour change 
	 * 
	 * @return                 the FillTransition object for changing 
	 *                         colour of the shape passed
	 */
	public static FillTransition changeColour(Shape shape, Color color) {
		
		FillTransition fill = new FillTransition(Duration.seconds(5), shape, 
				Color.web("#DFCA00"), color);
		
		return fill;
	}

	/**
	 * @param args  the command line arguments
	 *            
	 */
	public static void main(String[] args) {
		
		launch(args);
	}

```
###### test\doordonote\ui\UITest.java
``` java
package doordonote.ui;

import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.text.SimpleDateFormat;
import java.text.ParseException;

import doordonote.common.DeadlineTask;
import doordonote.common.EventTask;
import doordonote.common.FloatingTask;
import doordonote.common.Task;
import doordonote.ui.DateUtil;
import doordonote.ui.UI;

import org.junit.Before;
import org.junit.Test;

public class UITest {
	
	/** initialising a UI object for setting count value */
	private UI ui = new UI();
	
	/** SimpleDateFormat objects for parsing String objects of following formats into Dates */
	private SimpleDateFormat formatter = new SimpleDateFormat("dd/MM/yyyy HH:mm");
	private SimpleDateFormat formatter2 = new SimpleDateFormat("MM/dd/yyyy");

	/** String objects for dates to be parsed into Date Objects */
	private static final String dateInString1 = "31/10/2015 04:30";
	private static final String dateInString2 = "02/03/2016 12:05";
	private static final String dateInString3 = "13/12/2015 00:00";
	private static final String dateInString4 = "19/06/2016 23:45";
	private static final String dateInString5 = "31/10/2015 06:30";
    
	/** Date objects to be initialised after parsing of date strings */
	private Date dt1;
	private Date dt2;
	private Date dt3;
	private Date dt4;
	private Date dt5;
	
	@Before
	public void setup() throws ParseException{
		dt1 = formatter.parse(dateInString1);
		dt2 = formatter.parse(dateInString2);
		dt3 = formatter.parse(dateInString3);
		dt4 = formatter.parse(dateInString4);
		dt5 = formatter.parse(dateInString5);
	}

	/**
	 * Runs the String getDay(Calendar) method test for DateUtil class
	 * 
	 */
	@Test
	public void testGetDay() {
		
			Calendar cl1 = DateUtil.dateToCalendar(dt1);
			Calendar cl2 = DateUtil.dateToCalendar(dt2);

			String day1 = DateUtil.getDay(cl1);
			String day2 = DateUtil.getDay(cl2);

			assertEquals("Saturday", day1);
			assertEquals("Wednesday", day2);
	}

	/**
	 * Runs the String getMonth(Calendar) method test for DateUtil class
	 * 
	 */
	@Test
	public void testGetMonth() {

			Calendar cl1 = DateUtil.dateToCalendar(dt1);
			Calendar cl3 = DateUtil.dateToCalendar(dt3);

			String month1 = DateUtil.getMonth(cl1);
			String month3 = DateUtil.getMonth(cl3);

			assertEquals("Oct", month1);
			assertEquals("Dec", month3);

	}
    
	/**
	 * Runs the String getMinutes(Calendar) method test for DateUtil class
	 * 
	 */
	@Test
	public void testGetMinutes() {

			Calendar cl1 = DateUtil.dateToCalendar(dt1);
			Calendar cl3 = DateUtil.dateToCalendar(dt3);

			String minutes1 = DateUtil.getMinutes(cl1);
			String minutes3 = DateUtil.getMinutes(cl3);

			assertEquals("30", minutes1);
			assertEquals(null, minutes3);

	}

	/**
	 * Runs the String getTime(Calendar) method test for DateUtil class
	 * 
	 */
	@Test
	public void testGetTime() {

			Calendar cl1 = DateUtil.dateToCalendar(dt1);
			Calendar cl2 = DateUtil.dateToCalendar(dt2);
			Calendar cl3 = DateUtil.dateToCalendar(dt3);
			Calendar cl4 = DateUtil.dateToCalendar(dt4);

			String time1 = DateUtil.getTime(cl1);
			String time2 = DateUtil.getTime(cl2);
			String time3 = DateUtil.getTime(cl3);
			String time4 = DateUtil.getTime(cl4);

			assertEquals("4:30am", time1);
			assertEquals("12:05pm", time2);
			assertEquals("12am", time3);
			assertEquals("11:45pm", time4);

	}

	/**
	 * Runs the boolean checkForOverdue(Date) method test for DateUtil class
	 * 
	 */
	@Test
	public void testCheckForOverdue() {

			boolean overdue1 = DateUtil.checkForOverdue(dt1);
			boolean overdue2 = DateUtil.checkForOverdue(dt2);
			boolean overdue3 = DateUtil.checkForOverdue(dt3);
			boolean overdue4 = DateUtil.checkForOverdue(dt4);

			assertEquals(overdue1, true);
			assertEquals(overdue2, false);
			assertEquals(overdue3, false);
			assertEquals(overdue4, false);
	}
	
	/**
	 * Runs the boolean checkForOngoing(Date, Date) method test for DateUtil class
	 * 
	 */
	@Test
	public void testCheckForOngoing() {

			boolean ongoing1 = DateUtil.checkForOngoing(dt1, dt3);
			boolean ongoing2 = DateUtil.checkForOngoing(dt2, dt4);
			boolean ongoing3 = DateUtil.checkForOngoing(dt1, dt2);

			assertEquals(ongoing1, true);
			assertEquals(ongoing2, false);
			assertEquals(ongoing3, true);
	}
    
	/**
	 * Runs the String getMultipleDayEventString(Task) method test for UI class
	 * 
	 */
	@Test
	public void testGetMultipleDayEventString() {

			Task task1 = new EventTask("Flying Pig", dt1, dt3);
			Task task2 = new EventTask("Finish Project", dt3, dt2);

			String eventString1 = UI.getMultipleDayEventString(task1);
			String eventString2 = UI.getMultipleDayEventString(task2);

			assertEquals("1. [Saturday, 31 Oct, 4:30am - Sunday, 13 Dec, 12am] Flying Pig", eventString1);
			assertEquals("2. [Sunday, 13 Dec, 12am - Wednesday, 2 Mar, 12:05pm] Finish Project", eventString2);

	}
    
	/**
	 * Runs the boolean checkForEventsSpanningDays(List<Task>, SimpleDateFormat) 
	 * method test for UI class
	 * 
	 */
	@Test
	public void testCheckForEventsSpanningDays() {

			Task task1 = new EventTask("Flying Pig", dt1, dt3);
			Task task2 = new FloatingTask("Do CS homework");
			Task task3 = new EventTask("Swimming", dt1, dt5);
			Task task4 = new DeadlineTask("Running", dt4);

			ArrayList<Task> list1 = new ArrayList<Task>();
			ArrayList<Task> list2 = new ArrayList<Task>();

			list1.add(task1);
			list1.add(task2);
			list1.add(task3);
			list1.add(task4);

			list2.add(task2);
			list2.add(task3);
			list2.add(task4);

			boolean check1 = UI.checkForEventsSpanningDays(list1, formatter2);
			boolean check2 = UI.checkForEventsSpanningDays(list2, formatter2);

			assertEquals(check1, true);
			assertEquals(check2, false);
	}
    
	/**
	 * Runs the String getDateString(Task) method test for UI class
	 * 
	 */
	@Test
	public void testGetDateString() {

			Task task1 = new EventTask("Swimming", dt1, dt5);
			Task task2 = new DeadlineTask("Running", dt4);

			String date1 = UI.getDateToBeDisplayedString(task1);
			String date2 = UI.getDateToBeDisplayedString(task2);

			assertEquals(date1, "Saturday, 31 Oct");
			assertEquals(date2, "Sunday, 19 Jun");
	}

	/**
	 * Runs the String getDeadlineString(Task) method test for UI class
	 * 
	 */
	@Test
	public void testGetDeadlineString() {

			Task task1 = new DeadlineTask("Swimming", dt1);
			Task task2 = new DeadlineTask("Running", dt4);

			String deadlineTask1 = UI.getDeadlineString(task1);
			String deadlineTask2 = UI.getDeadlineString(task2);

			assertEquals(deadlineTask1, "1. [by 4:30am] Swimming");
			assertEquals(deadlineTask2, "2. [by 11:45pm] Running");

	}
    
	/**
	 * Runs the String getSingleDayEventString(Task) method test for UI class
	 * 
	 */
	@Test
	public void testGetSingleDayEventString() {

			Task task = new EventTask("Swimming", dt1, dt5);

			String eventTask = UI.getSingleDayEventString(task);

			assertEquals(eventTask, "1. [4:30am-6:30am] Swimming");

	}
    
	/**
	 * Runs the boolean checkForSameDay(Task, Task) method test for DateUtil class
	 * 
	 */
	@Test
	public void testCheckForSameDay() {

			Task task1 = new EventTask("Swimming", dt1, dt5);
			Task task2 = new DeadlineTask("Running", dt5);
			Task task3 = new DeadlineTask("assignment", dt1);
			Task task4 = new DeadlineTask("HW", dt2);
			Task task5 = new EventTask("Ball", dt4, dt4);

			boolean check1 = DateUtil.checkForSameDay(task1, task2);
			boolean check2 = DateUtil.checkForSameDay(task2, task3);
			boolean check3 = DateUtil.checkForSameDay(task1, task3);
			boolean check4 = DateUtil.checkForSameDay(task1, task5);
			boolean check5 = DateUtil.checkForSameDay(task1, task4);
			boolean check6 = DateUtil.checkForSameDay(task3, task4);
			boolean check7 = DateUtil.checkForSameDay(task2, task5);

			assertEquals(check1, false);
			assertEquals(check2, false);
			assertEquals(check3, false);
			assertEquals(check4, true);
			assertEquals(check5, true);
			assertEquals(check6, true);
			assertEquals(check7, true);

	}

	/**
	 * Runs the boolean checkIfMultipleDayEvent(Task, SimpleDateFormat) method 
	 * test for DateUtil class
	 * 
	 */
	@Test
	public void testCheckIfMultipleDayEvent() {

			Task task1 = new EventTask("Flying Pig", dt1, dt3);
			Task task2 = new EventTask("Swimming", dt1, dt5);

			boolean check1 = DateUtil.checkIfMultipleDayEvent(task1, formatter2);
			boolean check2 = DateUtil.checkIfMultipleDayEvent(task2, formatter2);

			assertEquals(check1, true);
			assertEquals(check2, false);
	}
}
```
