# A0131436N
###### src\doordonote\command\AddCommand.java
``` java

package doordonote.command;

import java.io.IOException;
import java.util.Date;

import doordonote.common.Util;
import doordonote.logic.CommandToController;

/**
 * @author yunpeng
 *
 */
public class AddCommand implements Command {
	protected String taskDescription = null;
	protected Date startDate = null;
	protected Date endDate = null;
	
	/**
	 * @param 	taskDescription 
	 * 			the description of the task to be added
	 * @param 	startDate
	 * 			The start date of the event. A null value indicates this task is not an event
	 * @param 	endDate
	 * 			The end date of the event. A null value indicates this task is not a deadline
	 */
	public AddCommand(String taskDescription, Date startDate, Date endDate) {
		// AddHandler should have checked that task is not null and not empty
		assert(taskDescription != null && !Util.isBlankString(taskDescription));
		
		this.taskDescription = taskDescription;
		this.startDate = startDate;
		this.endDate = endDate;
	}
	
	@Override
	public String execute(CommandToController controller) throws IOException {
		assert(controller != null);
		return controller.add(taskDescription, startDate, endDate);
	}
}
```
###### src\doordonote\command\Command.java
``` java

package doordonote.command;

import java.io.IOException;

import doordonote.logic.CommandToController;

/**
 * @author yunpeng 
 */
public interface Command {
	/**
	 * @param 	controller
	 * 			methods in the controller will be called
	 * @return 	feedback that gives information about the outcome of the execution of the command
	 * @throws IOException 
	 * @throws Exception 
	 */
	String execute(CommandToController controller) throws IOException, Exception;
}
```
###### src\doordonote\command\DeleteCommand.java
``` java

package doordonote.command;

import doordonote.logic.CommandToController;

/**
 * @author yunpeng
 *
 */
public class DeleteCommand implements Command {
	int taskID = -1;
	
	/**
	 * @param 	taskID
	 * 			This is the ID of the task users will see in the UI.
	 */
	public DeleteCommand(int taskID) {
		// DeleteHandler should have checked that taskID is more than zero
		assert(taskID > 0);
		this.taskID = taskID;
	}

	@Override
	public String execute(CommandToController controller) throws Exception {
		return controller.delete(taskID);
	}

}
```
###### src\doordonote\command\DisplayDeletedTaskCommand.java
``` java

package doordonote.command;

import java.io.IOException;

import doordonote.logic.CommandToController;

/**
 * @author yunpeng
 * 
 * This {@code Command} displays a list of deleted {@code Task} to the user
 *
 */
public class DisplayDeletedTaskCommand implements Command {
	
	@Override
	public String execute(CommandToController controller) throws IOException {
		return controller.displayDeleted();
	}

}
```
###### src\doordonote\command\DisplayFinishedTaskCommand.java
``` java

package doordonote.command;

import java.io.IOException;

import doordonote.logic.CommandToController;

/**
 * @author yunpeng
 *
 * This {@code Command} displays a list of finished {@code Task} to the user
 */
public class DisplayFinishedTaskCommand implements Command {
	
	@Override
	public String execute(CommandToController controller) throws IOException {
		return controller.displayFinished();
	}

}
```
###### src\doordonote\command\FindCommand.java
``` java

package doordonote.command;

import java.io.IOException;
import java.util.List;

import doordonote.logic.CommandToController;

/**
 * @author yunpeng
 *
 */
public class FindCommand implements Command {
	protected List<String> keywords = null;
	
	/**
	 * @param 	keywords
	 * 		  	Filters and displays only tasks that contains (not case sensitive) 
	 * 			every String in this {@code List}.
	 */
	public FindCommand(List<String> keywords) {
		this.keywords = keywords;
	}

	@Override
	public String execute(CommandToController controller) throws IOException {
		return controller.find(keywords);
	}

}
```
###### src\doordonote\command\FindDateCommand.java
``` java

package doordonote.command;

import java.io.IOException;
import java.util.Date;

import doordonote.logic.CommandToController;

public class FindDateCommand implements Command {
	protected Date startDate = null;
	
	public FindDateCommand(Date startDate) {
		assert(startDate != null);
		this.startDate = startDate;
	}

	@Override
	public String execute(CommandToController controller) throws IOException, Exception {
		return controller.find(startDate);
	}
}
```
###### src\doordonote\command\FinishCommand.java
``` java

package doordonote.command;

import doordonote.logic.CommandToController;

/**
 * @author yunpeng
 *
 */
public class FinishCommand implements Command {
	protected int taskIdToFinish = -1;
	
	/**
	 * @param 	taskIdToFinish
	 * 			This is the ID of the task users will see in the UI.
	 */
	public FinishCommand(int taskIdToFinish) {
		assert(taskIdToFinish > 0);
		this.taskIdToFinish = taskIdToFinish;
	}

	@Override
	public String execute(CommandToController controller) throws Exception {
		return controller.finish(taskIdToFinish);
	}

}
```
###### src\doordonote\command\HelpCommand.java
``` java

package doordonote.command;

import doordonote.logic.CommandToController;

/**
 * @author yunpeng
 *
 */
public class HelpCommand implements Command {
	protected String commandType = null;
	
	public HelpCommand(String commandType) {
		this.commandType = commandType; 
	}
	
	public HelpCommand() {}

	@Override
	public String execute(CommandToController controller) {
		if (commandType == null) {
			return controller.help();
		} else {
			return controller.help(commandType);
		}
	}

}
```
###### src\doordonote\command\HomeCommand.java
``` java

package doordonote.command;

import java.io.IOException;

import doordonote.logic.CommandToController;

/**
 * @author yunpeng
 * This command is used to display the default task lists.
 *
 */
public class HomeCommand implements Command{
	@Override
	public String execute(CommandToController controller) throws IOException {
		assert(controller != null);
		return controller.home();
	}
}
```
###### src\doordonote\command\RedoCommand.java
``` java

package doordonote.command;

import java.io.IOException;

import doordonote.logic.CommandToController;

/**
 * @author yunpeng
 *	Redo the effects made by {@code UndoCommand}
 */
public class RedoCommand implements Command {
	@Override
	public String execute(CommandToController controller) throws IOException {
		return controller.redo();
	}

}
```
###### src\doordonote\command\RestoreCommand.java
``` java

package doordonote.command;

import doordonote.logic.CommandToController;

/**
 * @author yunpeng
 *
 */
public class RestoreCommand implements Command {
	protected int indexToRestore = -1;

	/**
	 * @param 	indexToRestore
	 * 		 	restores a deleted/ finished {@code Task}
	 * 		 	Task restored is marked as undeleted and unfinished
	 */
	public RestoreCommand(int indexToRestore) {
		assert(indexToRestore > 0);
		this.indexToRestore = indexToRestore;
	}

	@Override
	public String execute(CommandToController controller) throws Exception {
		return controller.restore(indexToRestore);
	}

}
```
###### src\doordonote\command\UndoCommand.java
``` java

package doordonote.command;

import java.io.IOException;

import doordonote.logic.CommandToController;

/**
 * @author yunpeng
 *
 *	Undo the previous action that modified the storage file.
 *	(E.g. AddCommand/ DeleteCommand/ UpdateCommand)
 */
public class UndoCommand implements Command {
	@Override
	public String execute(CommandToController controller) throws IOException {
		return controller.undo();
	}

}
```
###### src\doordonote\command\UpdateCommand.java
``` java

package doordonote.command;

import java.util.Date;

import doordonote.logic.CommandToController;

/**
 * @author yunpeng
 */
public class UpdateCommand implements Command {
	protected int taskID = -1;
	protected String taskDescription = null;
	protected Date startDate = null;
	protected Date endDate = null;
	
	/**
	 * @param 	taskID
	 * 			Task ID to be updated. This task will be deleted and replaced by a new Task
	 * @param 	taskDescription
	 * 			Task description that will replace the old task
	 * @param 	startDate
	 * @param 	endDate
	 */
	public UpdateCommand(int taskID, String taskDescription, Date startDate, Date endDate) {
		this(taskID);
		// UpdateHandler should have checked that taskDescription is not null and not empty
		assert(taskDescription != null && !taskDescription.isEmpty()); 	
		
		this.taskDescription = taskDescription;
		this.startDate = startDate;
		this.endDate = endDate;
		this.taskID = taskID;
	}
	
	public UpdateCommand(int taskID) {
		// UpdateHandler should have checked that taskID > 0
		assert(taskID > 0); 
		this.taskID = taskID;
		this.taskDescription = null;
	}

	@Override
	public String execute(CommandToController controller) throws Exception {
		if (taskDescription == null) {
			return controller.getTaskID(this.taskID);
		}
		return controller.update(taskID, taskDescription, startDate, endDate);
	}
	



}
```
###### src\doordonote\commandfactory\AbstractAddCommandHandler.java
``` java

package doordonote.commandfactory;

import java.util.Date;
import java.util.List;

import doordonote.common.Util;

// TODO: Change name to make it more understandable
// TODO: Make parser static
public abstract class AbstractAddCommandHandler extends CommandHandler {

	protected DateParser dateParser = null;
	protected Date startDate = null;
	protected Date endDate = null;
	protected String taskDescription = null;
	
	public AbstractAddCommandHandler(String commandBody, DateParser dateParser) throws EmptyCommandBodyException {
		super(commandBody);
		if (Util.isBlankString(commandBody)) {
			throw new EmptyCommandBodyException();
		}
		this.dateParser = dateParser;			
		initialiseParameters(commandBody);
	}

	private void initialiseParameters(String commandBody) {
		if (isProbablyEvent()) {
			try {
				String dateString = commandBody.substring(getEventStartDateIndex());
				List<Date> dateList = dateParser.parseAndGetDateList(dateString);
//				Date startDate = dateParser.parse(startDateString);
//				Date endDate = dateParser.parse(endDateString);
				
				if (dateList == null || dateList.size() < 2) {
					taskDescription = commandBody;
				} else {
					taskDescription = getTaskDescription(getEventStartDateIndex());
					this.startDate = dateList.get(0);
					this.endDate = dateList.get(1);
				}
			} catch (Exception e) {
				taskDescription = commandBody;
			}
		} else if (isProbablyDeadline()) {
			try {
				String endDateString = commandBody.substring(getDeadlineDateIndex());
				Date endDate = dateParser.parse(endDateString);
				
				if (endDate == null) {
					taskDescription = commandBody;
				} else {
					taskDescription = getTaskDescription(getDeadlineDateIndex());
					this.endDate = endDate;
				}
			} catch (Exception e) {
				taskDescription = commandBody;
			}
		} else {
			taskDescription = commandBody;
		}
	}
	
	protected Date getStartDate() {
		return startDate;
	}
	
	protected Date getEndDate() {
		return endDate;
	}
	
	private boolean isProbablyEvent() {
		return getEventStartDateIndex() > getDeadlineDateIndex();
	}
	
	private boolean isProbablyDeadline() {
		return getEventStartDateIndex() < getDeadlineDateIndex();
	}
	
	private int getEventStartDateIndex() {
		return commandBody.toLowerCase().lastIndexOf(" from ");
	}

	
	private int getDeadlineDateIndex() {
		return commandBody.toLowerCase().lastIndexOf(" by ");
	}
	
	private String getTaskDescription(int endIndex) {
		return commandBody.substring(0, endIndex).trim();
	}
	
	protected String getTaskDescription() {
		return taskDescription;
	}
}
```
###### src\doordonote\commandfactory\AddHandler.java
``` java

package doordonote.commandfactory;

import java.util.Date;

import doordonote.command.AddCommand;
import doordonote.command.Command;
import doordonote.common.Util;

public class AddHandler extends AbstractAddCommandHandler {	
	private static final int MAX_TASK_DESCRIPTION_LENGTH = 500;
	private static final String MSG_TASK_TOO_LONG = "Task description is too long! Maximum number of characters is 500";

	public AddHandler(String commandBody, DateParser dateParser) throws EmptyCommandBodyException {
		super(commandBody, dateParser);
		if (Util.isEmptyOrNull(commandBody)) {
			throw new EmptyCommandBodyException();
		}
	}

	@Override
	public Command generateCommand() throws Exception {
		String taskDescription = getTaskDescription();
		if (taskDescription.length() > MAX_TASK_DESCRIPTION_LENGTH) {
			throw new Exception(MSG_TASK_TOO_LONG);
		}
		
		Date startDate = getStartDate();
		Date endDate = getEndDate();
		
		return new AddCommand(taskDescription, startDate, endDate);
	}

}
```
###### src\doordonote\commandfactory\CommandFactory.java
``` java

package doordonote.commandfactory;

import doordonote.command.Command;
import doordonote.common.Util;

public class CommandFactory {
	DateParser dateParser;

	public CommandFactory() {
		dateParser = new DateParser();
	}

	public Command parse(String userInput) throws Exception {

		String trimmedInput = userInput.trim();
		String commandType = getCommandType(trimmedInput);
		String commandBody = Util.removeFirstWord(trimmedInput);
		CommandHandler handler = null;

		switch (commandType) {

		case "add" :
			// TODO addm and addh
			handler = new AddHandler(commandBody, dateParser);
			break;

		case "delete" :
			// fallthrough
		case "del":
			handler = new DeleteHandler(commandBody);
			break;

		case "update" :
			handler = new UpdateHandler(commandBody, dateParser);
			break;

		case "undo" :
			handler = new UndoHandler(commandBody);
			break;

		case "redo" :
			handler = new RedoHandler(commandBody);
			break;

		case "find" :
			handler = new FindHandler(commandBody, dateParser);
			break;

		case "finish" :
			// fallthrough
		case "complete" :
			handler = new FinishHandler(commandBody);
			break;

		case "help" :
			handler = new HelpHandler(commandBody);
			break;
		case "home" :
			handler = new HomeHandler(commandBody);
			break;
		case "restore" :
			handler = new RestoreHandler(commandBody);
			break;
		case "display" :
			handler = new DisplayHandler(commandBody);
			break;
		// case "get" :
		// case "path" :

		default:
			// treats user input as adding a new task by default if input does not match any command type
			handler = new AddHandler(trimmedInput, dateParser);
		}

		return handler.generateCommand();
	}

	protected static String getCommandType(String userCommand) {
		assert(userCommand != null);
		String commandType = Util.getFirstWord(userCommand).toLowerCase();
		return commandType;
	}


}
```
###### src\doordonote\commandfactory\CommandHandler.java
``` java

package doordonote.commandfactory;

import doordonote.command.Command;

public abstract class CommandHandler {
	protected String commandBody = null;
	
	public CommandHandler(String commandBody) {
		this.commandBody = commandBody;
	}

	public static int getTaskIdFromString(String taskIdString) {
		return Integer.parseInt(taskIdString);
	}
	
	public abstract Command generateCommand() throws NumberFormatException, NegativeIndexException, ExcessArgumentException, Exception;
}
```
###### src\doordonote\commandfactory\DateParser.java
``` java

package doordonote.commandfactory;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.apache.log4j.BasicConfigurator;
import org.joda.time.DateTime;

import com.joestelmach.natty.CalendarSource;
import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

/**
 * @author yunpeng
 * A natty date parser wrapper that sets the default time to 8am in the morning.
 * Parser only takes dates in American date format. E.g. 10/3 is parsed as 3 Oct
 */
public class DateParser {
	protected Parser natty = null;

	public DateParser() {
		natty = new Parser();
    	BasicConfigurator.configure();
	}
	
	public Date parse(String input) {
		List<Date> dateList = parseAndGetDateList(input);
		if (dateList.isEmpty()) {
			return null;
		} else {
			return dateList.get(0);
		}
	}
	
	public Date parse(String input, Date defaultTime) {
		List<Date> dateList = parseAndGetDateList(input, defaultTime);
		if (dateList.isEmpty()) {
			return null;
		} else {
			return dateList.get(0);
		}
	}
	
	public List<Date> parseAndGetDateList(String input) {
		DateTime midnightToday = new DateTime().withTimeAtStartOfDay();
		DateTime eightAm = midnightToday.plusHours(8);
		Date defaultDate = eightAm.toDate();
		return parseAndGetDateList(input, defaultDate);
	}
	
	public List<Date> parseAndGetDateList(String input, Date defaultTime) {
		// input should always be checked to be no null
		assert(input != null);
		CalendarSource.setBaseDate(defaultTime);
		List<DateGroup> baseDateList = natty.parse(input);
		try {
			DateGroup baseDateGroup = baseDateList.get(0);
			List<Date> dateList = baseDateGroup.getDates();
			return dateList;
		} catch (IndexOutOfBoundsException e) {
			return new ArrayList<Date>();
		}	
	}
}
```
###### src\doordonote\commandfactory\DeleteHandler.java
``` java

package doordonote.commandfactory;

import doordonote.command.Command;
import doordonote.command.DeleteCommand;
import doordonote.common.Util;

public class DeleteHandler extends CommandHandler {
	
	public DeleteHandler(String commmandBody) throws EmptyCommandBodyException {
		super(commmandBody);
		if (Util.isEmptyOrNull(commandBody)) {
			throw new EmptyCommandBodyException();
		}
	}

	@Override
	public Command generateCommand() throws NumberFormatException, NegativeIndexException {
		int indexToDelete = getTaskIdFromString(commandBody);
		if (indexToDelete <= 0) {
			throw new NegativeIndexException();
		} else {
			return new DeleteCommand(indexToDelete);
		}	
	}

}
```
###### src\doordonote\commandfactory\DisplayHandler.java
``` java

package doordonote.commandfactory;

import com.sun.xml.internal.fastinfoset.stax.events.Util;

import doordonote.command.Command;
import doordonote.command.DisplayDeletedTaskCommand;
import doordonote.command.DisplayFinishedTaskCommand;

public class DisplayHandler extends CommandHandler {

	public DisplayHandler(String commandBody) throws EmptyCommandBodyException {
		super(commandBody);
		if (Util.isEmptyString(commandBody)) {
			throw new EmptyCommandBodyException();
		}
	}

	@Override
	public Command generateCommand() throws Exception {
		if (commandBody.trim().toLowerCase().equals("deleted")) {
			return new DisplayDeletedTaskCommand();
		} else if (commandBody.trim().toLowerCase().equals("finished")) {
			return new DisplayFinishedTaskCommand();
		} else {
			throw new Exception("Invalid display arguments");
		}
	}

}
```
###### src\doordonote\commandfactory\EmptyCommandBodyException.java
``` java

package doordonote.commandfactory;

public class EmptyCommandBodyException extends Exception {

	/**
	 * 
	 */
	private static final long serialVersionUID = 4789438006018030330L;

	public EmptyCommandBodyException() {
		super("Invalid command format. This command needs arguments");
	}
}
```
###### src\doordonote\commandfactory\ExcessArgumentException.java
``` java

package doordonote.commandfactory;

public class ExcessArgumentException extends Exception {

	/**
	 * 
	 */
	private static final long serialVersionUID = -4517966650474754315L;
	
	public ExcessArgumentException() {
		super("Invalid command format. Too many arguments used in command");
	}
}
```
###### src\doordonote\commandfactory\FindHandler.java
``` java

package doordonote.commandfactory;

import java.util.Arrays;
import java.util.Date;
import java.util.List;

import org.joda.time.DateTime;

import doordonote.command.Command;
import doordonote.command.FindCommand;
import doordonote.command.FindDateCommand;
import doordonote.common.Util;

public class FindHandler extends CommandHandler {
	protected DateParser dateParser = null; 
	
	public FindHandler(String commmandBody, DateParser parser) throws EmptyCommandBodyException {
		super(commmandBody);
		if (Util.isEmptyOrNull(commandBody)) {
			throw new EmptyCommandBodyException();
		}
		dateParser = parser;			
	}

	@Override
	public Command generateCommand() {
		String firstWord = Util.getFirstWord(commandBody);
		if (firstWord.equalsIgnoreCase("from")) {
			DateTime midnightToday = new DateTime().withTimeAtStartOfDay();
			Date defaultTime = midnightToday.toDate();

			Date startDate = dateParser.parse(commandBody, defaultTime);
			if (startDate != null) {
				return new FindDateCommand(startDate);
			}
		}
		
		String[] keywordsArray= commandBody.split("\\s+");
		List<String> keywords = Arrays.asList(keywordsArray);
		return new FindCommand(keywords);
	}

}
```
###### src\doordonote\commandfactory\FinishHandler.java
``` java

package doordonote.commandfactory;

import doordonote.command.Command;
import doordonote.command.FinishCommand;
import doordonote.common.Util;

public class FinishHandler extends CommandHandler {

	public FinishHandler(String commmandBody) throws EmptyCommandBodyException {
		super(commmandBody);
		if (Util.isEmptyOrNull(commandBody)) {
			throw new EmptyCommandBodyException();
		}
	}

	@Override
	public Command generateCommand() throws NumberFormatException, NegativeIndexException {
		int indexToFinish = getTaskIdFromString(commandBody);
		if (indexToFinish <= 0) {
			throw new NegativeIndexException();
		} else {
			return new FinishCommand(indexToFinish);
		}	
	}

}
```
###### src\doordonote\commandfactory\HelpHandler.java
``` java

package doordonote.commandfactory;

import doordonote.command.Command;
import doordonote.command.HelpCommand;
import doordonote.common.Util;

public class HelpHandler extends CommandHandler {

	public HelpHandler(String commmandBody) {
		super(commmandBody);
	}

	@Override
	public Command generateCommand() {
		if (Util.isEmptyOrNull(commandBody)) {
			return new HelpCommand();
		} else {
			return new HelpCommand(commandBody);
		}
	}

}
```
###### src\doordonote\commandfactory\HomeHandler.java
``` java

package doordonote.commandfactory;

import doordonote.command.Command;
import doordonote.command.HomeCommand;
import doordonote.common.Util;

public class HomeHandler extends CommandHandler {

	public HomeHandler(String commmandBody) throws ExcessArgumentException {
		super(commmandBody);
		if (!commandBody.isEmpty()) {
			throw new ExcessArgumentException();
		}
	}

	@Override
	public Command generateCommand() throws ExcessArgumentException {
		if (Util.isEmptyOrNull(commandBody)) {
			return new HomeCommand();
		} else {
			// this command should not have any arguments
			throw new ExcessArgumentException();
		}
	}

}
```
###### src\doordonote\commandfactory\NegativeIndexException.java
``` java

package doordonote.commandfactory;

public class NegativeIndexException extends Exception {

	/**
	 * 
	 */
	private static final long serialVersionUID = -5240083176979243708L;

	public NegativeIndexException() {
		super("Invalid index value");
	}
}
```
###### src\doordonote\commandfactory\NoTaskFoundException.java
``` java

package doordonote.commandfactory;

public class NoTaskFoundException extends Exception {
	
	/**
	 * 
	 */
	private static final long serialVersionUID = -5240083176979243708L;

	public NoTaskFoundException() {
		super("No task found");
	}

}
```
###### src\doordonote\commandfactory\RedoHandler.java
``` java

package doordonote.commandfactory;

import doordonote.command.Command;
import doordonote.command.RedoCommand;
import doordonote.common.Util;

public class RedoHandler extends CommandHandler {

	public RedoHandler(String commmandBody) throws ExcessArgumentException {
		super(commmandBody);
		if (!Util.isEmptyOrNull(commandBody)) {
			throw new ExcessArgumentException();
		}
	}

	@Override
	public Command generateCommand() {
		return new RedoCommand();
	}

}
```
###### src\doordonote\commandfactory\RestoreHandler.java
``` java

package doordonote.commandfactory;

import doordonote.command.Command;
import doordonote.command.RestoreCommand;
import doordonote.common.Util;

public class RestoreHandler extends CommandHandler {

	public RestoreHandler(String commandBody) throws EmptyCommandBodyException {
		super(commandBody);
		if (Util.isEmptyOrNull(commandBody)) {
			throw new EmptyCommandBodyException();
		}
	}

	@Override
	public Command generateCommand() throws NumberFormatException, NegativeIndexException {
		int indexToRestore = getTaskIdFromString(commandBody);
		if (indexToRestore <= 0) {
			throw new NegativeIndexException();
		} else {
			return new RestoreCommand(indexToRestore);
		}	
	}

}
```
###### src\doordonote\commandfactory\UndoHandler.java
``` java

package doordonote.commandfactory;

import doordonote.command.Command;
import doordonote.command.UndoCommand;
import doordonote.common.Util;

public class UndoHandler extends CommandHandler {

	public UndoHandler(String commmandBody) throws ExcessArgumentException {
		super(commmandBody);
		if (!Util.isEmptyOrNull(commandBody)) {
			throw new ExcessArgumentException();
		}
	}

	@Override
	public Command generateCommand() {
		return new UndoCommand();
	}

}
```
###### src\doordonote\commandfactory\UpdateHandler.java
``` java

package doordonote.commandfactory;

import java.util.Date;

import doordonote.command.Command;
import doordonote.command.UpdateCommand;
import doordonote.common.Util;

public class UpdateHandler extends AbstractAddCommandHandler {
	public UpdateHandler(String commandBody, DateParser dateParser) throws EmptyCommandBodyException {
		super(commandBody, dateParser);
		if (commandBody.isEmpty()) {
			throw new EmptyCommandBodyException();
		}
	}

	
	// TODO: Add in handler for commands such as "update 5"
	@Override
	public Command generateCommand() throws NumberFormatException, NegativeIndexException {
		int indexToUpdate = getIndexToUpdate();
		String taskDescription = getTaskDescription();
		Date startDate = getStartDate();
		Date endDate = getEndDate();
		if (Util.isBlankString(taskDescription)) {
			return new UpdateCommand(indexToUpdate);
		}
		return new UpdateCommand(indexToUpdate, taskDescription, startDate, endDate);
	}
	
	@Override
	protected String getTaskDescription() {
		return Util.removeFirstWord(super.getTaskDescription());		
	}
	
	protected int getIndexToUpdate() throws NumberFormatException, NegativeIndexException {
		int indexToUpdate = Integer.parseInt(Util.getFirstWord(commandBody));
		if (indexToUpdate <= 0) {
			 throw new NegativeIndexException();
		} else {
			return indexToUpdate;
		}
	}
	

}
```
###### src\doordonote\common\Util.java
``` java

package doordonote.common;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

public final class Util {

	private Util() {
		// TODO Auto-generated constructor stub
	}
	
	public static String removeFirstWord(String input) {
		return input.replace(getFirstWord(input), "").trim();
	}

	public static String getFirstWord(String input) {
		String commandTypeString = input.trim().split("\\s+")[0];
		return commandTypeString;
	}
	
	public static boolean isEmptyOrNull(String input) {
		return (input == null || input.trim().isEmpty());
	}
	
	
	public static boolean isBlankString(String input) {
		return input.trim().isEmpty();
	}
	
	public static String getDateString(Date input) {
		if (input == null) {
			return null;
		} else {
			DateFormat dateFormatter = new SimpleDateFormat();
			return dateFormatter.format(input);
		}
	}
	
	
	// Yong rui
	public static Task createTask(String description, Date startDate, Date endDate){
		Task task = null;

		if(description!=null && startDate==null && endDate==null){
			task = new FloatingTask(description);
		} else if(description!=null && startDate==null && endDate!=null){
			task = new DeadlineTask(description, endDate);
		} else if(description!=null && startDate!=null && endDate!=null){
			task = new EventTask(description, startDate, endDate);
		} else {
			assert (task != null):"Invalid Task parameters";
		}

		return task;
	}
}
```
###### src\doordonote\logic\CommandToController.java
``` java

package doordonote.logic;

import java.io.IOException;
import java.util.Date;
import java.util.List;

import doordonote.common.Task;

public interface CommandToController {
	String add(String taskDescription, Date startDate, Date endDate) throws IOException;

	String delete(int taskId) throws Exception;

	String find(List<String> keywords) throws IOException;
	
	String finish(int taskId) throws IOException, Exception;
	
	String help();
	
	String help(String commandType);
	
	String redo() throws IOException;
	
	String undo() throws IOException;
	
	String update(int taskId, String taskDescription, Date startDate, Date endDate) throws Exception;
	
	String home() throws IOException;

	String restore(int taskId) throws IOException, Exception;

	String displayFinished() throws IOException;

	String displayDeleted() throws IOException;

	String getTaskID(int taskID) throws Exception;

	UIState getState();

	List<Task> getUserTaskList() throws IOException;

	String find(Date startDate) throws IOException;
}
```
###### src\doordonote\logic\Controller.java
``` java

package doordonote.logic;

import java.io.IOException;
import java.util.Date;
import java.util.List;

import doordonote.common.Task;
import doordonote.common.Util;
import doordonote.logic.UIState.ListType;
import doordonote.storage.Storage;
import doordonote.storage.StorageHandler;

//import doordonote.storage.Task;

public class Controller implements CommandToController {
	
	private static final String MESSAGE_HOME = "Displaying all unfinished task(s)";
	
	protected Storage storage = null;
	protected UIState stateObj = null;
	protected TaskListFilter taskFilter = null;
	
	
	public Controller() throws IOException {
		storage = StorageHandler.getInstance();		
		stateObj = new UIState();
		taskFilter = new TaskListFilter(storage);
	}
	
	/**
	 * @param store
	 * 
	 * Used for injection dependency to replace Storage with a stub for testing
	 */
	protected void setStorageTaskList(Storage storage) {
		this.storage = storage;
		taskFilter.setStorage(storage);
	}

	@Override
	public String add(String taskDescription, Date startDate, Date endDate) throws IOException {
		List<Task> oldTaskList = taskFilter.getUserTaskList(stateObj);
		Task taskToBeAdded = Util.createTask(taskDescription, startDate, endDate);
		String outputMsg = storage.add(taskToBeAdded);
		
		taskFilter.updateFullTaskList();
		
		if (stateObj.displayType != ListType.NORMAL) {
			stateObj.setDefault();
		} else {
			List<Task> newTaskList = taskFilter.getUserTaskList(stateObj);
			if (newTaskList.size() > oldTaskList.size()) {
				stateObj.clearTempState();				
			} else {
				stateObj.setDefault();
			}
		}
		stateObj.idNewTask = getNewTaskId(taskToBeAdded);
		return outputMsg;
	}

	@Override
	public String delete(int taskId) throws Exception {
		stateObj.clearTempState();
		Task taskToDelete = getTask(taskId);
		String outputMsg = null;
		if (stateObj.displayType == ListType.DELETED) {
			outputMsg = storage.remove(taskToDelete);
		} else {
			outputMsg = storage.delete(taskToDelete);

		}
		taskFilter.updateFullTaskList();
		return outputMsg;
	}
	
	protected Task getTask(int taskId) throws Exception {
		List<Task> userTaskList = taskFilter.getUserTaskList(stateObj);
		if (taskId > userTaskList.size()) {
			throw new Exception("Invalid taskID!");
		}
		return userTaskList.get(taskId - 1);
	}
	

	@Override
	public String find(List<String> keywords) throws IOException {
		stateObj.clearTempState();
		stateObj.filterList = keywords;
		stateObj.startDate = null;
		
		List<Task> userTaskList = taskFilter.getUserTaskList(stateObj);
		
		if (!userTaskList.isEmpty()) {
			return userTaskList.size() + " task(s) found";
		} else {
			return "No task found!";
		}
	}

	@Override
	public String finish(int taskId) throws Exception {
		stateObj.clearTempState();

		Task taskToFinish = getTask(taskId);
		String outputMsg = storage.finish(taskToFinish);
    	return outputMsg;
	}
	
	@Override
	public UIState getState() {
		return stateObj;
	}

	@Override
	public String help() {
		stateObj.clearTempState();
		stateObj.helpBox = "help";
		return "Displaying help";
	}

	@Override
	public String help(String commandType) {
		stateObj.clearTempState();

		stateObj.helpBox = commandType;
		return "Displaying " + commandType + " help";
	}

	@Override
	public String redo() throws IOException {
		String outputMsg = storage.redo();
		taskFilter.updateFullTaskList();
		stateObj.setDefault();
		return outputMsg;
	}

	@Override
	public String undo() throws IOException {
		String outputMsg = storage.undo();
		taskFilter.updateFullTaskList();
		stateObj.setDefault();
		return outputMsg;
	}

	@Override
	public String update(int taskId, String taskDescription, Date startDate, Date endDate) throws Exception {
		stateObj.clearTempState();

		if (stateObj.displayType == ListType.FINISHED || stateObj.displayType == ListType.DELETED) {
			throw new Exception("Cannot update deleted/ finished tasks!");
		}
		
		Task taskToUpdate = getTask(taskId);
		Task newTask = Util.createTask(taskDescription, startDate, endDate);
		String outputMsg = storage.update(taskToUpdate, newTask);

		taskFilter.updateFullTaskList();
		
		stateObj.idNewTask = getNewTaskId(newTask);
		return outputMsg;
	}
	
	@Override
	public String home() throws IOException {
		stateObj.setDefault();
		taskFilter.updateFullTaskList();
		return MESSAGE_HOME;
	}


	@Override
	public String restore(int taskId) throws Exception {
		stateObj.clearTempState();

		if (stateObj.displayType == ListType.NORMAL) {
			throw new Exception("Cannot restore an undeleted/ unfinished task!");
		}
		
		Task taskToRestore = getTask(taskId);
		String outputMsg = storage.restore(taskToRestore);
		return outputMsg;
	}


	@Override
	public String displayFinished() throws IOException {
		stateObj.setDefault();
		stateObj.displayType = ListType.FINISHED;
		return "Displaying finished tasks";
	}


	@Override
	public String displayDeleted() throws IOException {
		stateObj.setDefault();
		stateObj.displayType = ListType.DELETED;
		return "Displaying deleted tasks";
	}

	public String displayOverDue() throws IOException {
		stateObj.setDefault();
		stateObj.displayType = ListType.OVERDUE;
		return "Displaying overdue tasks";		
	}
	
	@Override
	public String getTaskID(int taskId) throws Exception {
		stateObj.clearTempState();
		Task taskToBeUpdated = getTask(taskId);
		stateObj.inputBox = getTaskToBeUpdated(taskToBeUpdated, taskId);
		return "Task " + taskId + " found!";
	}


	protected String getTaskToBeUpdated(Task taskToBeUpdated, int taskId) {
		String taskDescription = taskToBeUpdated.getDescription();
		Date startDate = taskToBeUpdated.getStartDate();
		Date endDate = taskToBeUpdated.getEndDate();
		String startDateString = Util.getDateString(startDate);
		String endDateString = Util.getDateString(endDate);

		String taskString = null;
		if (endDate == null) {
			taskString = taskDescription;
		} else if (startDate == null) {
			taskString = taskDescription + " by " + endDateString;
		} else {
			taskString = taskDescription + " from " + startDateString + " to " + endDateString;
		}
		return "update " + taskId + " " + taskString;
	}
	
	/**
	 * @param oldTaskList
	 * @return taskId of new task added
	 */
	protected int getNewTaskId(Task newTask) {
		List<Task> userTaskList = taskFilter.getUserTaskList(stateObj);
		return userTaskList.indexOf(newTask);
	}

	@Override
	public List<Task> getUserTaskList() throws IOException {
		List<Task> userTaskList = taskFilter.getUserTaskList(stateObj);
		return userTaskList;
	}

	@Override
	public String find(Date startDate) throws IOException {
		assert(startDate != null);
		stateObj.clearTempState();
		stateObj.startDate = startDate;
		stateObj.filterList = null;
		return "Displaying from " + Util.getDateString(startDate);
	}


}
```
###### src\doordonote\logic\Logic.java
``` java

package doordonote.logic;

import java.io.IOException;
import java.util.List;

import doordonote.command.Command;
import doordonote.commandfactory.CommandFactory;
import doordonote.common.Task;

public class Logic implements UIToLogic {
	protected CommandFactory cmdFactory = null;
	protected CommandToController controller = null;
	
	public Logic() throws IOException {
		cmdFactory = new CommandFactory();
		controller = new Controller();
	}
	
	@Override
	public String parseAndExecuteCommand(String userInput) throws Exception {
		Command cmd = cmdFactory.parse(userInput);
		return cmd.execute(controller);
	}
	
	@Override
	public UIState getState() {
		return controller.getState();
	}

	@Override
	public List<Task> getTasks() {
		List<Task> taskList = null;
		try {
			taskList = controller.getUserTaskList();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return taskList;
	}
	

}
```
###### src\doordonote\logic\TaskListFilter.java
``` java

package doordonote.logic;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import doordonote.common.Task;
import doordonote.storage.Storage;

public class TaskListFilter {
	
	protected Storage storage = null;
	protected ArrayList<Task> fullTaskList;
	
	protected TaskListFilter(Storage storage) throws IOException {
		this.storage = storage;
		fullTaskList = storage.readTasks();
	}
	
	protected void setStorage(Storage storage) {
		this.storage = storage;
	}
	
	public void updateFullTaskList() throws IOException {
		fullTaskList = storage.readTasks();
	}
	
	public List<Task> getUserTaskList(UIState stateObj) {
		List<Task> userTaskList = null;
		switch (stateObj.displayType) {
		case DELETED :
			userTaskList = getDeletedTasks();
			break;
		case FINISHED :
			userTaskList = getFinishedTasks();
			break;
		case OVERDUE :
			userTaskList = getOverdueTasks();
			break;
		case NORMAL :
			// fallthrough
		default :
			userTaskList = getUnfinishedTasks();
		}
		
		if (userTaskList.isEmpty()) {
			return userTaskList;
		}
		
		if (stateObj.startDate != null) {
			return filter(userTaskList, stateObj.startDate);
		} else if (stateObj.filterList == null || stateObj.filterList.isEmpty()) {
			return userTaskList;
		} else {
			return filter(userTaskList, stateObj.filterList);
		}
	}
	

	protected List<Task> filter(List<Task> unfilteredUserTaskList, Date startDate) {
		assert(startDate != null);
		List<Task> userTaskList = new ArrayList<Task>();
		for (Task task : unfilteredUserTaskList) {
			if (task.getEndDate() != null && task.getEndDate().after(startDate)) {
				userTaskList.add(task);
			}
		}

		return userTaskList;		
	}

	protected List<Task> filter(List<Task> unfilteredUserTaskList, List<String> filterList) {
		List<Task> tempList = null;
		List<Task> userTaskList = unfilteredUserTaskList;
		for (String keyword : filterList) {
			tempList = new ArrayList<Task>();
			for (Task task : userTaskList) {
				if (task.getDescription().toLowerCase().contains(keyword.toLowerCase())) {
					tempList.add(task);
				}
			}
			userTaskList = tempList;
		}
		return userTaskList;
	}

		private List<Task> getUnfinishedTasks() {
		List<Task> unfinishedTaskList = new ArrayList<Task>();
		for(Task task : fullTaskList) {
			if (!task.isDone() && !task.isDeleted()) {
				unfinishedTaskList.add(task);
			}
		}
		return unfinishedTaskList;
	}
	
	private List<Task> getOverdueTasks() {
//		List<Task> overDueTasks = new ArrayList<Task>();
//		for(Task task : fullTaskList) {
//			if (task.getEndDate()) {
//				unfinishedTaskList.add(task);
//			}
//		}
//		return unfinishedTaskList;
		return null;
	}

```
###### src\doordonote\logic\UIState.java
``` java

package doordonote.logic;

import java.util.Date;
import java.util.List;

public class UIState {
	public enum ListType {
	    DELETED, FINISHED, NORMAL, OVERDUE
	}
	
	
	protected String inputBox = null;
	protected String helpBox = null;
	protected ListType displayType = null;
	protected int idNewTask = -1;
	protected List<String> filterList = null;
	protected Date startDate = null;
	
	public UIState() {
		setDefault();
	}
	
	public int getIdNewTask() {
		return idNewTask;
	}

	public ListType getDisplayType() {
		return displayType;
	}

	public String getInputBox() {
		return inputBox;
	}
	public String getHelpBox() {
		return helpBox;
	}
	public String getTitle() {
		String title = "";
		switch (displayType) {
		case NORMAL :
			title = "";
			break;
		case FINISHED :
			title = "Finished Tasks";
			break;
		case DELETED :
			title = "Deleted Tasks";
			break;
		case OVERDUE :
			title = "Overdue Tasks";
			break;
		default :
			
		}
		if (filterList == null || filterList.isEmpty()) {
			return title;
		} else {
			title += " Filter by: ";
			for (String word : filterList) {
				title += word + ", ";
			}
			return title;
		}
		
		
	}

	protected void clearTempState() {
		inputBox = "";
		helpBox = null;
		idNewTask = -1;
	}
	
	protected void setDefault() {
		inputBox = "";
		displayType = ListType.NORMAL;
		helpBox = null;
		idNewTask = -1;
		filterList = null;
		startDate = null;
	}
	
	
	
}
```
###### src\doordonote\logic\UIToLogic.java
``` java

package doordonote.logic;

import java.io.IOException;
import java.util.List;

import doordonote.common.Task;

public interface UIToLogic {
	List<Task> getTasks();
	String parseAndExecuteCommand(String userInput) throws Exception;
	UIState getState();
}
```
###### test\doordonote\commandfactory\CommandFactoryTest.java
``` java

package doordonote.commandfactory;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

public class CommandFactoryTest {
	private CommandFactory cmdFactory = new CommandFactory();

	@Test
	public void getCommandTypeTest() {
		assertEquals("getCommandType should be case insensitive", 
					 "add", 
					 CommandFactory.getCommandType("AdD list of statements"));
		
		assertEquals("getCommandType should be robust to leading spaces",
				 	 "test", 
				 	 CommandFactory.getCommandType("  test  list of "));
		assertEquals("getCommandType should be return empty string for blank strings",
			 	 	 "", 
			 	 	 CommandFactory.getCommandType("   "));	
	}
	
	@Test
	public void parseTest() {
		
	}

}
```
###### test\doordonote\commandfactory\DateParserTest.java
``` java

package doordonote.commandfactory;

import static org.junit.Assert.assertEquals;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.joda.time.DateTime;
import org.junit.Test;

public class DateParserTest {
	
	private DateParser parser = new DateParser();

	
	@Test
	public void parseAndGetDateListTest() {
		DateTime dt1 = new DateTime(2013, 1, 15, 8, 0, 0, 0);
		DateTime dt2 = new DateTime(2015, 3, 30, 8, 0, 0, 0);
	    Date jdkDate1 = dt1.toDate();
	    Date jdkDate2 = dt2.toDate();
	    List<Date> createdDateList = new ArrayList<Date>();
	    createdDateList.add(jdkDate1);
	    createdDateList.add(jdkDate2);
	    List<Date> parsedDateList = parser.parseAndGetDateList("from 15 jan 2013 to 30 march  8");
        
	    assertEquals("Parser should get list of 2 dates", createdDateList, parsedDateList);
	    
	    createdDateList.remove(1);
	    //check that parser only parse one date when no connecting words like "to" is used
	    assertEquals("Parser should get only one valid date without 'to'", 
	    			 createdDateList, 
	    			 parser.parseAndGetDateList("from 15 jan 2013 30 march  7.45"));
	    assertEquals("Parser should return empty if no dates are found", 
	    			 new ArrayList<Date>(), 
	    			 parser.parseAndGetDateList("do research on database"));


	}
	
	@Test
	public void parseTest() {
		// Creates DateTime object with information like year, month,
        // day, hour, minute, second and milliseconds
		DateTime dt1 = new DateTime(2015, 11, 24, 8, 0, 0, 0);
	    Date jdkDate1 = dt1.toDate();
	    
		DateTime dt2 = new DateTime(2015, 4, 8, 12, 0, 0, 0);
	    Date jdkDate2 = dt2.toDate();
        assertEquals("Parser should return default time at 8am", jdkDate1, parser.parse("nov 24"));
        assertEquals("Parser should be able to deal with leading/ trailing space", 
        			 jdkDate2, 
        			 parser.parse("april 8   12pm"));
        assertEquals("Parser should be able to take empty strings", null, parser.parse(""));
	}

}
```
###### test\doordonote\logic\ControllerTest.java
``` java

package doordonote.logic;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

public class ControllerTest {

	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
	}

	@Before
	public void setUp() throws Exception {
	}

	@Test
	public void test() {
		fail("Not yet implemented");
	}

}
```
###### test\doordonote\logic\StorageStub.java
``` java

package doordonote.logic;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;

import doordonote.common.Task;
import doordonote.storage.Storage;

public class StorageStub implements Storage {

	@Override
	public String path(String location) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String get(String location) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String add(Task task) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String add(String description, Date startDate, Date endDate) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String update(Task taskToUpdate, String descirption, Date startDate, Date endDate) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String update(Task oldTask, Task newTask) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String delete(Task taskToDelete) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String remove(Task taskToRemove) throws IOException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public ArrayList<Task> readTasks() throws IOException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public ArrayList<Task> readDeletedTasks() throws IOException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public ArrayList<Task> readDoneTasks() throws IOException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String clear() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String undo() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String redo() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String restore(Task task) throws IOException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String finish(Task task) throws IOException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String notFinish(Task task) throws IOException {
		// TODO Auto-generated method stub
		return null;
	}

}
```
