# A0131436N
###### src\doordonote\command\AddCommand.java
``` java

/**
 * @author yunpeng
 *
 */
public class AddCommand implements Command {
	protected String taskDescription = null;
	protected Date startDate = null;
	protected Date endDate = null;
	
	/**
	 * @param 	taskDescription 
	 * 			the description of the task to be added
	 * @param 	startDate
	 * 			The start date of the event. A null value indicates this task is not an event
	 * @param 	endDate
	 * 			The end date of the event. A null value indicates this task is not a deadline
	 */
	public AddCommand(String taskDescription, Date startDate, Date endDate) {
		// AddHandler should have checked that task is not null and not empty
		assert(taskDescription != null && !Util.isBlankString(taskDescription));
		
		this.taskDescription = taskDescription;
		this.startDate = startDate;
		this.endDate = endDate;
	}
	
	@Override
	public String execute(CommandToController controller) throws IOException, DuplicateTaskException {
		assert(controller != null);
		return controller.add(taskDescription, startDate, endDate);
	}
}
```
###### src\doordonote\command\Command.java
``` java

/**
 * Interface where new concrete Command implementations should inherit from.
 * 
 */
public interface Command {
	/**
	 * Executes this command
	 * 
	 * @param 	controller
	 * 			methods in the controller will be called
	 * @return 	feedback that gives information about the outcome of the execution of the command
	 * @throws 	IOException 
	 * @throws 	Exception 
	 */
	String execute(CommandToController controller) throws IOException, Exception;
}
```
###### src\doordonote\command\DeleteCommand.java
``` java

/**
 * @author yunpeng
 *
 */
public class DeleteCommand implements Command {
	int taskID = -1;
	
	/**
	 * @param 	taskID
	 * 			This is the ID of the task users will see in the UI.
	 */
	public DeleteCommand(int taskID) {
		// DeleteHandler should have checked that taskID is more than zero
		assert(taskID > 0);
		this.taskID = taskID;
	}

	@Override
	public String execute(CommandToController controller) throws Exception {
		return controller.delete(taskID);
	}

}
```
###### src\doordonote\command\FindCommand.java
``` java

/**
 * @author yunpeng
 *
 */
public class FindCommand implements Command {
	protected List<String> keywords = null;
	
	/**
	 * @param 	keywords
	 * 		  	Filters user task list by only tasks that contains (not case sensitive) 
	 * 			words in {@code keywords}.
	 */
	public FindCommand(List<String> keywords) {
		assert(keywords != null);
		this.keywords = keywords;
	}

	@Override
	public String execute(CommandToController controller) throws IOException {
		return controller.find(keywords);
	}

}
```
###### src\doordonote\command\FindDateCommand.java
``` java

/**
 * @author yunpeng
 *
 */
public class FindDateCommand implements Command {
	protected Date startDate = null;
	
	/**
	 * @param 	startDate
	 * 			Filters user task list by only tasks that end after {@code startDate}.
	 * 			Floating task should not be displayed
	 */
	public FindDateCommand(Date startDate) {
		assert(startDate != null);
		this.startDate = startDate;
	}

	@Override
	public String execute(CommandToController controller) throws IOException, Exception {
		return controller.find(startDate);
	}
}
```
###### src\doordonote\command\FinishCommand.java
``` java

/**
 * @author yunpeng
 *
 */
public class FinishCommand implements Command {
	protected int taskIdToFinish = -1;
	
	/**
	 * Marks a task as finished.
	 * 
	 * @param 	taskIdToFinish
	 * 			This is the ID of the task users will see in the UI.
	 */
	public FinishCommand(int taskIdToFinish) {
		assert(taskIdToFinish > 0);
		this.taskIdToFinish = taskIdToFinish;
	}

	@Override
	public String execute(CommandToController controller) throws Exception {
		return controller.finish(taskIdToFinish);
	}

}
```
###### src\doordonote\command\GetPathCommand.java
``` java

/**
 * This Command display the path of the storage file to the user
 * 
 * @author yunpeng
 *
 */
public class GetPathCommand implements Command {

	@Override
	public String execute(CommandToController controller) throws IOException, Exception {
		return controller.getCurrentFilePath();
	}

}
```
###### src\doordonote\command\HelpCommand.java
``` java

/**
 *	Command to display help to users.
 */
public class HelpCommand implements Command {
	protected String commandType = null;
	
	/**
	 * @param 	commandType
	 * 			The command user needs help for.
	 */
	public HelpCommand(String commandType) {
		this.commandType = commandType; 
	}
	
	public HelpCommand() {
		
	}

	@Override
	public String execute(CommandToController controller) {
		if (commandType == null) {
			return controller.help();
		} else {
			return controller.help(commandType);
		}
	}

}
```
###### src\doordonote\command\HomeCommand.java
``` java

/**
 * @author yunpeng
 * This command is used to display the default task lists.
 *
 */
public class HomeCommand implements Command{
	@Override
	public String execute(CommandToController controller) throws IOException {
		assert(controller != null);
		return controller.home();
	}
}
```
###### src\doordonote\command\ReadPathCommand.java
``` java

/**
 * 
 * This {@code Command} is used to read from a storage file at the user input path. 
 *
 */
public class ReadPathCommand implements Command {
	protected String pathName = null;
	
	/**
	 * @param 	path
	 * 			File path of the .json storage file in the file system.
	 * 			File path can be absolute or relative to current folder.
	 */
	public ReadPathCommand(String path) {
		assert(path != null);
		pathName = path;
	}

	@Override
	public String execute(CommandToController controller) throws IOException, Exception {
		return controller.readFromFilePath(pathName);
	}

}
```
###### src\doordonote\command\RedoCommand.java
``` java

/**
 * @author yunpeng
 *	Redo the effects made by {@code UndoCommand}
 */
public class RedoCommand implements Command {
	@Override
	public String execute(CommandToController controller) throws IOException {
		return controller.redo();
	}

}
```
###### src\doordonote\command\RestoreCommand.java
``` java

/**
 * @author yunpeng
 *
 */
public class RestoreCommand implements Command {
	protected int indexToRestore = -1;

	/**
	 * @param 	indexToRestore
	 * 			Task ID to be restored.
	 * 		 	Task restored is treated as undeleted and unfinished
	 */
	public RestoreCommand(int indexToRestore) {
		assert(indexToRestore > 0);
		this.indexToRestore = indexToRestore;
	}

	@Override
	public String execute(CommandToController controller) throws Exception {
		return controller.restore(indexToRestore);
	}

}
```
###### src\doordonote\command\SetPathCommand.java
``` java

/**
 * Command used to save a storage file in a particular path in the file system.
 * If a file of the same name already exists, simply read from the existing file. 
 *
 */
public class SetPathCommand implements Command {
	protected String pathName = null;
	
	/**
	 * @param 	path
	 * 			Location on the file system to create .json storage file.
	 * 			If file already exists, simply read from it.
	 */
	public SetPathCommand(String path) {
		pathName = path;
	}

	@Override
	public String execute(CommandToController controller) throws IOException, Exception {
		return controller.saveFileAt(pathName);
	}

}
```
###### src\doordonote\command\UndoCommand.java
``` java

/**
 * @author yunpeng
 *
 *	Undo the previous action that modified the storage file.
 *	(E.g. AddCommand/ DeleteCommand/ UpdateCommand)
 */
public class UndoCommand implements Command {
	@Override
	public String execute(CommandToController controller) throws IOException {
		return controller.undo();
	}

}
```
###### src\doordonote\command\UpdateCommand.java
``` java

/**
 * @author yunpeng
 */
public class UpdateCommand implements Command {
	protected int taskID = -1;
	protected String taskDescription = null;
	protected Date startDate = null;
	protected Date endDate = null;
	
	/**
	 * @param 	taskID
	 * 			Task ID to be updated. This task will be deleted and replaced by a new Task.
	 * @param 	taskDescription
	 * 			Task description that will replace the old task.
	 * @param 	startDate
	 * @param 	endDate
	 */
	public UpdateCommand(int taskID, String taskDescription, Date startDate, Date endDate) {
		// UpdateHandler should have checked that taskID > 0
		this(taskID);
		// UpdateHandler should have checked that taskDescription is not null and not empty
		assert(taskID > 0);
		assert(taskDescription != null && !taskDescription.isEmpty()); 	
		
		this.taskDescription = taskDescription;
		this.startDate = startDate;
		this.endDate = endDate;
		this.taskID = taskID;
	}
	
	/**
	 * @param 	taskID
	 * 			Task ID to be updated.
	 * 			This constructor returns the details of the task to be updated to the
	 *			user's input box as a {@code String} so that users can more easily
	 *			modify the contents of the {@code Task}. 
	 *			The actual {@code Task} object is not modified.
	 * 			
	 */
	public UpdateCommand(int taskID) {
		// UpdateHandler should have checked that taskID > 0
		assert(taskID > 0); 
		this.taskID = taskID;
		this.taskDescription = null;
	}

	@Override
	public String execute(CommandToController controller) throws Exception {
		if (taskDescription == null) {
			return controller.getTaskStringToUserInputBoxById(this.taskID);
		}
		return controller.update(taskID, taskDescription, startDate, endDate);
	}
	



}
```
###### src\doordonote\command\ViewDeletedTaskCommand.java
``` java

/**
 * @author yunpeng
 * 
 * This {@code Command} displays a list of deleted {@code Task} to the user
 *
 */
public class ViewDeletedTaskCommand implements Command {
	
	@Override
	public String execute(CommandToController controller) throws IOException {
		return controller.viewDeleted();
	}

}
```
###### src\doordonote\command\ViewFinishedTaskCommand.java
``` java

/**
 * @author yunpeng
 *
 * This {@code Command} displays a list of finished {@code Task} to the user
 */
public class ViewFinishedTaskCommand implements Command {
	
	@Override
	public String execute(CommandToController controller) throws IOException {
		return controller.viewFinished();
	}

}
```
###### src\doordonote\commandfactory\AbstractAddCommandHandler.java
``` java

/**
 * Parses dates from user input String. Extended by AddCommand and UpdateCommand
 * 
 * @author yunpeng
 *
 */
public abstract class AbstractAddCommandHandler extends CommandHandler {
	protected static final String EXCEPTION_STARTDATE_AFTER_ENDDATE = "End date (%1$s) must be later than Start date (%2$s)";
	protected static final String EXCEPTION_TASK_TOO_LONG = "Task description is too long! Maximum number of characters is 500";
	
	private static final int MAX_TASK_DESCRIPTION_LENGTH = 500;

	protected DateParser dateParser = null;
	protected Date startDate = null;
	protected Date endDate = null;
	protected String taskDescription = null;

	public AbstractAddCommandHandler(String commandBody, DateParser dateParser, String cmdType) throws Exception {
		super(commandBody);
		if (Util.isEmptyOrNull(commandBody)) {
			throw new Exception(String.format(EXCEPTION_NO_ARGUMENT, cmdType));
		}
		this.dateParser = dateParser;
		initialiseParameters(commandBody);
	}

	/**
	 * Parses and sets the taskDescription, startDate and endDate field
	 * 
	 * @param commandBody
	 *            User input.
	 * @throws Exception
	 *             Throws exception if an event startDate is later than its
	 *             endDate.
	 */
	private void initialiseParameters(String commandBody) throws Exception {
		if (isProbablyEvent()) {
			setEventStartAndEndDate(commandBody);
		} else if (isProbablyDeadline()) {
			setDeadlineDate(commandBody);
		} else {
			taskDescription = commandBody;
		}
	}

	private void setDeadlineDate(String commandBody) {
		String endDateString = commandBody.substring(getDeadlineDateIndex());
		Date endDate = dateParser.parse(endDateString);

		if (endDate == null) {
			taskDescription = commandBody;
		} else {
			taskDescription = getTaskDescription(getDeadlineDateIndex());
			this.endDate = endDate;
		}
	}

	private void setEventStartAndEndDate(String commandBody) throws Exception {
		String dateString = commandBody.substring(getEventStartDateIndex());
		List<Date> dateList = dateParser.parseAndGetDateList(dateString);

		if (dateList == null || dateList.size() < 2) {
			taskDescription = commandBody;
		} else {
			taskDescription = getTaskDescription(getEventStartDateIndex());
			this.startDate = dateList.get(0);
			this.endDate = dateList.get(1);

			if (startDate.compareTo(endDate) >= 0) {
				throw new Exception(String.format(EXCEPTION_STARTDATE_AFTER_ENDDATE, Util.getDateString(endDate),
						Util.getDateString(startDate)));
			}
		}
	}

	protected Date getStartDate() {
		return startDate;
	}

	protected Date getEndDate() {
		return endDate;
	}

	private boolean isProbablyEvent() {
		return getEventStartDateIndex() > getDeadlineDateIndex();
	}

	private boolean isProbablyDeadline() {
		return getEventStartDateIndex() < getDeadlineDateIndex();
	}

	private int getEventStartDateIndex() {
		return commandBody.toLowerCase().lastIndexOf(" from ");
	}

	private int getDeadlineDateIndex() {
		return commandBody.toLowerCase().lastIndexOf(" by ");
	}

	private String getTaskDescription(int endIndex) {
		return commandBody.substring(0, endIndex).trim();
	}

	protected String getTaskDescription() throws Exception {
		if (taskDescription.length() > MAX_TASK_DESCRIPTION_LENGTH) {
			throw new Exception(EXCEPTION_TASK_TOO_LONG);
		}
		return taskDescription;
	}
}
```
###### src\doordonote\commandfactory\AddHandler.java
``` java

public class AddHandler extends AbstractAddCommandHandler {
	
	protected AddHandler(String commandBody, DateParser dateParser) throws Exception {
		super(commandBody, dateParser, "add");
	}

	@Override
	public Command generateCommand() throws Exception {
		String taskDescription = getTaskDescription();
		Date startDate = getStartDate();
		Date endDate = getEndDate();

		return new AddCommand(taskDescription, startDate, endDate);
	}

}
```
###### src\doordonote\commandfactory\CommandFactory.java
``` java

public class CommandFactory {
	DateParser dateParser;

	public CommandFactory() {
		dateParser = new DateParser();
	}

	public Command parse(String userInput) throws Exception {

		String trimmedInput = userInput.trim();
		String commandType = getCommandType(trimmedInput);
		String commandBody = Util.removeFirstWord(trimmedInput);
		CommandHandler handler = null;

		switch (commandType) {

		case "add" :
			handler = new AddHandler(commandBody, dateParser);
			break;

		case "delete" :
			// fallthrough
		case "del":
			handler = new DeleteHandler(commandBody);
			break;

		case "update" :
			handler = new UpdateHandler(commandBody, dateParser);
			break;

		case "undo" :
			handler = new UndoHandler(commandBody);
			break;

		case "redo" :
			handler = new RedoHandler(commandBody);
			break;

		case "find" :
			handler = new FindHandler(commandBody, dateParser);
			break;

		case "finish" :
			// fallthrough
		case "fin" :
			handler = new FinishHandler(commandBody);
			break;

		case "help" :
			handler = new HelpHandler(commandBody);
			break;
		case "home" :
			handler = new HomeHandler(commandBody);
			break;
		case "restore" :
			handler = new RestoreHandler(commandBody);
			break;
		case "view" :
			handler = new ViewHandler(commandBody);
			break;
		 case "readfrom" :
			 handler = new ReadPathHandler(commandBody);
			 break;
		 case "save" :
			 handler = new SetPathHandler(commandBody);
			 break;
		default:
			// treats user input as adding a new task by default if input does not match any command type
			handler = new AddHandler(trimmedInput, dateParser);
		}

		return handler.generateCommand();
	}

	protected static String getCommandType(String userCommand) {
		assert(userCommand != null);
		String commandType = Util.getFirstWord(userCommand).toLowerCase();
		return commandType;
	}


}
```
###### src\doordonote\commandfactory\CommandHandler.java
``` java

/**
 * Creates a concrete {@code Command} object. 
 * 
 * @author yunpeng
 *
 */
public abstract class CommandHandler {
	protected String commandBody = null;
	protected static final String EXCEPTION_NO_ARGUMENT = "%1$s command requires arguments. Type 'help %1$s' for more details.";
	protected static final String EXCEPTION_EXCESS_ARGUMENTS = "%1$s should not have any arguments. Type 'help %1$s' for more details.";
	protected static final String EXCEPTION_INVALID_TASK_ID_FORMAT = "%1$s expects a positive integer as Task ID. Type 'help %1$s' for more details.";
	protected static final String EXCEPTION_INVALID_TASK_ID_VALUE = "Task ID cannot be less than 1!";

	protected CommandHandler(String commandBody) {
		this.commandBody = commandBody;
	}

	public static int getTaskIdFromString(String taskIdString, String cmdType) throws Exception {
		int taskId;
		try {
			taskId = Integer.parseInt(taskIdString);
		} catch (NumberFormatException e) {
			throw new Exception(String.format(EXCEPTION_INVALID_TASK_ID_FORMAT, cmdType));
		}
		
		if (taskId <= 0) {
			throw new Exception(EXCEPTION_INVALID_TASK_ID_VALUE);
		}
		return taskId;
	}

	/**
	 * Generates a {@code Command} that will be executed.
	 * This method should be overridden by concrete {@code CommandHandler} class.
	 * 
	 * @return A {@code Command} that is to be executed.
	 * @throws NumberFormatException
	 * @throws Exception
	 */
	public abstract Command generateCommand() throws NumberFormatException, Exception;
}
```
###### src\doordonote\commandfactory\DateParser.java
``` java

/**
 * @author yunpeng
 * A natty date parser wrapper that sets the default time to 8am in the morning.
 * Parser only takes dates in American date format. E.g. 10/3 is parsed as 3 Oct
 */
public class DateParser {
	protected Parser natty = null;

	protected DateParser() {
		BasicConfigurator.configure();
		natty = new Parser();
	}
	
	public Date parse(String input) {
		List<Date> dateList = parseAndGetDateList(input);
		if (dateList == null) {
			return null;
		} else {
			return dateList.get(0);
		}
	}
	
	public Date parse(String input, Date defaultTime) {
		List<Date> dateList = parseAndGetDateList(input, defaultTime);
		if (dateList == null) {
			return null;
		} else {
			return dateList.get(0);
		}
	}
	
	public List<Date> parseAndGetDateList(String input) {
		Date defaultDate = getDateTodayEightAm();
		return parseAndGetDateList(input, defaultDate);
	}

	private Date getDateTodayEightAm() {
		DateTime midnightToday = new DateTime().withTimeAtStartOfDay();
		DateTime eightAm = midnightToday.plusHours(8);
		Date defaultDate = eightAm.toDate();
		return defaultDate;
	}
	
	public List<Date> parseAndGetDateList(String input, Date defaultTime) {
		assert(input != null); // input should always be checked to be no null
		
		CalendarSource.setBaseDate(defaultTime);
		List<DateGroup> baseDateGroupList = natty.parse(input);
		if (baseDateGroupList.isEmpty()) {
			return null;
		}
		DateGroup baseDateGroup = baseDateGroupList.get(0);
		List<Date> dateList = baseDateGroup.getDates();
		return dateList;
	}
}
```
###### src\doordonote\commandfactory\DeleteHandler.java
``` java

public class DeleteHandler extends CommandHandler {
	
	protected DeleteHandler(String commmandBody) throws Exception {
		super(commmandBody);
		if (Util.isEmptyOrNull(commandBody)) {
			throw new Exception(String.format(EXCEPTION_NO_ARGUMENT, "delete"));
		}
	}

	@Override
	public Command generateCommand() throws Exception {
		int indexToDelete = getTaskIdFromString(commandBody, "delete");
		return new DeleteCommand(indexToDelete);	
	}

}
```
###### src\doordonote\commandfactory\FindHandler.java
``` java

/**
 * Generates command to filter user task list based on either Date or a list of keywords
 * 
 * @author yunpeng
 *
 */
public class FindHandler extends CommandHandler {
	protected DateParser dateParser = null; 
	
	protected FindHandler(String commmandBody, DateParser parser) throws Exception {
		super(commmandBody);
		if (Util.isEmptyOrNull(commandBody)) {
			throw new Exception(String.format(EXCEPTION_NO_ARGUMENT, "find"));
		}
		dateParser = parser;			
	}

	@Override
	public Command generateCommand() {
		String firstWord = Util.getFirstWord(commandBody).toLowerCase();
		if (firstWord.equals("from")) {
			Date defaultTime = setDateToTodayMidnight();
			Date startDate = dateParser.parse(commandBody, defaultTime);
			if (startDate != null) {
				return new FindDateCommand(startDate);
			}
		}
		
		String[] keywordsArray= commandBody.split("\\s+");
		List<String> keywords = Arrays.asList(keywordsArray);
		return new FindCommand(keywords);
	}

	private Date setDateToTodayMidnight() {
		DateTime midnightToday = new DateTime().withTimeAtStartOfDay();
		Date defaultTime = midnightToday.toDate();
		return defaultTime;
	}

}
```
###### src\doordonote\commandfactory\FinishHandler.java
``` java

public class FinishHandler extends CommandHandler {

	protected FinishHandler(String commmandBody) throws Exception {
		super(commmandBody);
		if (Util.isEmptyOrNull(commandBody)) {
			throw new Exception(String.format(EXCEPTION_NO_ARGUMENT, "finish"));
		}
	}

	@Override
	public Command generateCommand() throws Exception {
		int indexToFinish = getTaskIdFromString(commandBody, "finish");
		return new FinishCommand(indexToFinish);
	}

}
```
###### src\doordonote\commandfactory\HelpHandler.java
``` java

public class HelpHandler extends CommandHandler {

	protected HelpHandler(String commmandBody) {
		super(commmandBody);
	}

	@Override
	public Command generateCommand() {
		if (Util.isEmptyOrNull(commandBody)) {
			return new HelpCommand();
		} else {
			return new HelpCommand(commandBody);
		}
	}

}
```
###### src\doordonote\commandfactory\HomeHandler.java
``` java

public class HomeHandler extends CommandHandler {

	protected HomeHandler(String commmandBody) throws Exception {
		super(commmandBody);
		if (!Util.isEmptyOrNull(commmandBody)) {
			throw new Exception(String.format(EXCEPTION_EXCESS_ARGUMENTS, "home"));
		}
	}

	@Override
	public Command generateCommand() {
		return new HomeCommand();
	}

}
```
###### src\doordonote\commandfactory\ReadPathHandler.java
``` java

/**
 * Reads the storage file from the user specified path.
 * If no path is specified, returns the current file path that is being used.
 * 
 * @author yunpeng
 *
 */
public class ReadPathHandler extends CommandHandler {

	protected ReadPathHandler(String commandBody) {
		super(commandBody);
	}

	@Override
	public Command generateCommand() {		
		if (Util.isEmptyOrNull(commandBody)) {
			return new GetPathCommand();
		}
		return new ReadPathCommand(commandBody);
	}

}
```
###### src\doordonote\commandfactory\RedoHandler.java
``` java

public class RedoHandler extends CommandHandler {

	protected RedoHandler(String commmandBody) throws Exception {
		super(commmandBody);
		if (!Util.isEmptyOrNull(commandBody)) {
			throw new Exception(String.format(EXCEPTION_EXCESS_ARGUMENTS, "redo"));
		}
	}

	@Override
	public Command generateCommand() {
		return new RedoCommand();
	}

}
```
###### src\doordonote\commandfactory\RestoreHandler.java
``` java

public class RestoreHandler extends CommandHandler {

	protected RestoreHandler(String commandBody) throws Exception {
		super(commandBody);
		if (Util.isEmptyOrNull(commandBody)) {
			throw new Exception(String.format(EXCEPTION_NO_ARGUMENT, "restore"));
		}
	}

	@Override
	public Command generateCommand() throws Exception {
		int indexToRestore = getTaskIdFromString(commandBody, "restore");
		return new RestoreCommand(indexToRestore);
	}

}
```
###### src\doordonote\commandfactory\SetPathHandler.java
``` java

/**
 * Sets the path where the storage file should be saved in the local file system.
 * 
 * @author yunpeng
 *
 */
public class SetPathHandler extends CommandHandler {

	protected SetPathHandler(String commandBody) throws Exception {
		super(commandBody);
		
		if (Util.isEmptyOrNull(commandBody)) {
			throw new Exception(String.format(EXCEPTION_NO_ARGUMENT, "save"));
		}
	}

	@Override
	public Command generateCommand() {
		return new SetPathCommand(commandBody);
	}

}
```
###### src\doordonote\commandfactory\UndoHandler.java
``` java

public class UndoHandler extends CommandHandler {

	protected UndoHandler(String commmandBody) throws Exception {
		super(commmandBody);
		if (!Util.isEmptyOrNull(commandBody)) {
			throw new Exception(String.format(EXCEPTION_EXCESS_ARGUMENTS, "undo"));
		}
	}

	@Override
	public Command generateCommand() {
		return new UndoCommand();
	}

}
```
###### src\doordonote\commandfactory\UpdateHandler.java
``` java

public class UpdateHandler extends AbstractAddCommandHandler {
	protected UpdateHandler(String commandBody, DateParser dateParser) throws Exception {
		super(commandBody, dateParser, "update");
	}

		@Override
	public Command generateCommand() throws Exception {
		int indexToUpdate = getIndexToUpdate();
		String taskDescription = getTaskDescription();
		Date startDate = getStartDate();
		Date endDate = getEndDate();
		if (Util.isBlankString(taskDescription)) {
			return new UpdateCommand(indexToUpdate);
		} else {			
			return new UpdateCommand(indexToUpdate, taskDescription, startDate, endDate);
		}
	}
	
	@Override
	protected String getTaskDescription() throws Exception {
		return Util.removeFirstWord(super.getTaskDescription());		
	}
	
	protected int getIndexToUpdate() throws Exception {
		String taskIdString = Util.getFirstWord(commandBody);
		int indexToUpdate = getTaskIdFromString(taskIdString, "update");
		return indexToUpdate;
	}
	

}
```
###### src\doordonote\commandfactory\ViewHandler.java
``` java

public class ViewHandler extends CommandHandler {
	protected static final String EXCEPTION_INVALID_VIEW_ARGUMENT = "Do you mean 'view deleted' or 'view finished'?";

	protected ViewHandler(String commandBody) throws Exception {
		super(commandBody);
		if (Util.isEmptyOrNull(commandBody)) {
			throw new Exception(String.format(EXCEPTION_NO_ARGUMENT, "view"));
		}
		this.commandBody = commandBody.trim().toLowerCase();
	}

	@Override
	public Command generateCommand() throws Exception {
		if (commandBody.contains("del")) {
			return new ViewDeletedTaskCommand();
		} else if (commandBody.contains("fin")) {
			return new ViewFinishedTaskCommand();
		} else {
			throw new Exception(EXCEPTION_INVALID_VIEW_ARGUMENT);
		}
	}

}
```
###### src\doordonote\common\Util.java
``` java

public final class Util {

	private Util() {
		// TODO Auto-generated constructor stub
	}
	
	public static String removeFirstWord(String input) {
		return input.replaceFirst(getFirstWord(input), "").trim();
	}

	public static String getFirstWord(String input) {
		String commandTypeString = input.trim().split("\\s+")[0];
		return commandTypeString;
	}
	
	public static boolean isEmptyOrNull(String input) {
		return (input == null || input.trim().isEmpty());
	}
	
	
	public static boolean isBlankString(String input) {
		return input.trim().isEmpty();
	}
	
	public static String getDateString(Date input) {
		if (input == null) {
			return null;
		} else {
			DateFormat dateFormatter = new SimpleDateFormat("d MMM ''yy H:mm");
			return dateFormatter.format(input);
		}
	}
	
	
```
###### src\doordonote\logic\CommandToController.java
``` java

public interface CommandToController {
	
	/**
	 * Adds a {@code Task} to storage.
	 * 
	 * @param taskDescription
	 * @param startDate
	 * @param endDate
	 * @return feedback message to be displayed to users.
	 * @throws IOException
	 * @throws DuplicateTaskException
	 */
	String add(String taskDescription, Date startDate, Date endDate) throws IOException, DuplicateTaskException;

	/**
	 * Marks a task as deleted.
	 * If task is already marked as deleted, delete it from the file.
	 * 
	 * @param 	taskId
	 * 			ID of task to be deleted.
	 * @return feedback message to be displayed to users.
	 * @throws Exception
	 */
	String delete(int taskId) throws Exception;

	/**
	 * Filters the list of task user can see based on the list of key words.
	 * Only tasks with task description that contains all the words in keywords will be
	 * displayed to the user.
	 * 
	 * @param 	keywords
	 * 			keywords used to filter the task list
	 * @return feedback message to be displayed to users.
	 * @throws IOException
	 */
	String find(List<String> keywords) throws IOException;
	
	/**
	 * Marks a task as done.
	 * 
	 * @param 	taskId
	 * 			ID of task to be mark as done.
	 * @return feedback message to be displayed to users.
	 * @throws IOException
	 * @throws Exception
	 */
	String finish(int taskId) throws IOException, Exception;
	
	/**
	 * Displays a help image
	 * 
	 * @return feedback message to be displayed to users.
	 */
	String help();
	
	/**
	 * Displays a help image of a specific commandType
	 * 
	 * @param 	commandType
	 * 			The specific command user needs help for.
	 * @return feedback message to be displayed to users.
	 */
	String help(String commandType);
	
	/**
	 * Redo the last undo.
	 * 
	 * @return feedback message to be displayed to users.
	 */
	String redo();
	
	/**
	 * Undo the last changes made to the file (e.g. add/ delete/ update/ finish/ restore).
	 * 
	 * @return feedback message to be displayed to users.
	 */
	String undo();
	
	/**
	 * Replaces the task specified with a completely new task.
	 * 
	 * @param 	taskId
	 * 			ID of task to be updated.
	 * @param taskDescription
	 * @param startDate
	 * @param endDate
	 * @return feedback message to be displayed to users.
	 * @throws Exception
	 */
	String update(int taskId, String taskDescription, Date startDate, Date endDate) throws Exception;
	
	/**
	 * Displays all undone and undeleted task to user.
	 * 
	 * @return feedback message to be displayed to users.
	 * @throws IOException
	 */
	String home() throws IOException;

	/**
	 * Marks a deleted/ done task as undeleted/ undone.
	 * 
	 * @param taskId
	 * @return feedback message to be displayed to users.
	 * @throws IOException
	 * @throws Exception
	 */
	String restore(int taskId) throws IOException, Exception;

	/**
	 * Displays all done tasks to user.
	 * 
	 * @return feedback message to be displayed to users.
	 */
	String viewFinished();

	/**
	 * Displays all deleted tasks to user.
	 * 
	 * @return feedback message to be displayed to users.
	 */
	String viewDeleted();

	/**
	 * Used by update to create a String from a Task. This method will
	 * allow users to easily edit a task by filling the user input area
	 * with the task that should be updated.
	 * 
	 * @param 	taskID
	 * 			ID of the task that will be converted to String.
	 * @return feedback message to be displayed to users.
	 * @throws Exception
	 */
	String getTaskStringToUserInputBoxById(int taskID) throws Exception;

	/**
	 * @return UIState object for UI to determine what kind of data should be displayed.
	 */
	UIState getState();

	/**
	 * Displays all tasks that ends after filterDate.
	 * 
	 * @param filterDate
	 * @return feedback message to be displayed to users.
	 * @throws IOException
	 */
	String find(Date filterDate) throws IOException;

	/**
	 * Reads a storage file from the specified path.
	 * 
	 * @param 	pathName
	 * 			File path to read storage file from. 
	 * @return feedback message to be displayed to users.
	 */
	String readFromFilePath(String pathName);

	/**
	 * Saves storage file in specified path.
	 * If a storage file with the same path already exists, read from the existing file.
	 * 
	 * @param pathName
	 * @return
	 */
	String saveFileAt(String pathName);

	/**
	 * @return List of sorted {@code Task}.
	 * @throws IOException
	 */
	List<Task> getTaskList() throws IOException;

	/**
	 * @return Path from which the current storage file is being read from.
	 */
	String getCurrentFilePath();

}
```
###### src\doordonote\logic\Controller.java
``` java

public class Controller implements CommandToController {

	private static final String USER_EDITABLE_TASK_FORMAT = "update %1$s %2$s";	
	
	private static final String MESSAGE_HOME = "Displaying all unfinished task(s)";
	private static final String MESSAGE_FIND = "%1$s task(s) found!";
	private static final String MESSAGE_HELP = "Displaying help.";
	private static final String MESSAGE_DELETED_LIST = "Displaying deleted tasks.";
	private static final String MESSAGE_FINISHED_LIST = "Displaying finished tasks.";
	private static final String MESSAGE_READING_FROM_PATH = "Currently reading from: %1$s";
	private static final String MESSAGE_TASK_FOUND = "Task %1$s found!";
	private static final String MESSAGE_FIND_BY_DATE = "Displaying tasks that ends after %1$s.";

	private static final String EXCEPTION_INVALID_TASK_ID = "Task ID %1$s is not valid. There are only %2$s task(s) in the list";
	private static final String EXCEPTION_TASK_ALREADY_FINISH = "Task is already finished!";
	private static final String EXCEPTION_CANNOT_UPDATE_FINISH_OR_DELETED_TASK = "Cannot update deleted/ finished tasks";
	private static final int UNDO_STACK_SIZE = 10;

	protected Storage storage = null;
	protected UIState stateObj = null;
	protected TaskFilter taskFilter = null;

	protected List<Task> userTaskList = null;

	protected Deque<UIState> undoStack = null;
	protected Stack<UIState> redoStack = null;

	public Controller() {
		this(StorageHandler.getInstance());
	}

	/**
	 * @param storage
	 * 
	 *            Constructor used for injection dependency to replace Storage
	 *            with a stub for testing
	 * @throws IOException
	 */
	protected Controller(Storage storage) {
		this.storage = storage;
		stateObj = new UIState();
		taskFilter = new TaskFilter(storage);
		undoStack = new LinkedList<UIState>();
		redoStack = new Stack<UIState>();
		userTaskList = null;
		try {
			updateTaskList();
		} catch (IOException e) {
			// Error opening storage file
			userTaskList = new ArrayList<Task>();
		}
	}

	
	@Override
	public String add(String taskDescription, Date startDate, Date endDate) throws IOException, DuplicateTaskException {
		assert(!Util.isEmptyOrNull(taskDescription));

		Task taskToBeAdded = Util.createTask(taskDescription, startDate, endDate);
		String outputMsg = storage.add(taskToBeAdded); // Throws exceptions
		addCurrentStateToUndoStackAndClearRedoStack();

		List<Task> oldTaskList = userTaskList;
		updateTaskList();
		setUIStateOnAdd(oldTaskList);
		stateObj.idNewTask = getNewTaskId(taskToBeAdded);
		return outputMsg;
	}

	/**
	 * Sets UIState to dedisplayType to NORMAL. If displayType is already
	 * NORMAL, compares taskList prior to calling this method and after calling
	 * this method. If there are more tasks in the new taskList, task is added
	 * to user task list without changing stateObj. Hence no need to change
	 * stateObj.
	 * 
	 * Else, task added may be filtered away by other parameters in stateObj.
	 * Set stateObj to default.
	 * 
	 * @param oldTaskList
	 * @throws IOException
	 */
	private void setUIStateOnAdd(List<Task> oldTaskList) {
		if (stateObj.displayType != ListType.NORMAL) {
			stateObj.setDefault();
		} else {
			assert(oldTaskList != null);

			if (userTaskList.size() <= oldTaskList.size()) {
				stateObj.setDefault();
			}
		}
	}
	

	@Override
	public String delete(int taskId) throws Exception {
		Task taskToDelete = getTask(taskId);
		String outputMsg = null;
		if (stateObj.displayType == ListType.DELETED) {
			outputMsg = storage.remove(taskToDelete);
		} else {
			outputMsg = storage.delete(taskToDelete);

		}
		addCurrentStateToUndoStackAndClearRedoStack();
		return outputMsg;
	}
	

	/**
	 * @param taskId
	 *            Id of Task to be returned.
	 * @return a Task
	 * @throws Exception
	 */
	private Task getTask(int taskId) throws Exception {
		if (taskId > userTaskList.size()) {
			throw new Exception(String.format(EXCEPTION_INVALID_TASK_ID, taskId, userTaskList.size()));
		}
		return userTaskList.get(taskId - 1);
	}

	
	@Override
	public String find(List<String> keywords) throws IOException {
		stateObj.filterList = keywords;
		stateObj.filterDate = null;

		updateTaskList();
		return String.format(MESSAGE_FIND, userTaskList.size());
	}

	
	@Override
	public String finish(int taskId) throws Exception {
		if (stateObj.displayType == ListType.FINISHED) {
			throw new Exception(EXCEPTION_TASK_ALREADY_FINISH);
		}

		Task taskToFinish = getTask(taskId);
		String outputMsg = storage.finish(taskToFinish);
		addCurrentStateToUndoStackAndClearRedoStack();

		return outputMsg;
	}
	

	
	@Override
	public UIState getState() {
		// Create a copy to prevent modification by other classes.
		UIState copyOfUIState = new UIState(stateObj);
		stateObj.clearTempState();
		return copyOfUIState;
	}
	

	
	@Override
	public String help() {
		stateObj.helpBox = "help";
		return MESSAGE_HELP;
	}

	@Override
	public String help(String commandType) {
		stateObj.helpBox = commandType;
		return MESSAGE_HELP;
	}

	@Override
	public String redo() {
		String outputMsg = storage.redo();
		setCurrentStateFromRedoStack();
		return outputMsg;
	}

	private void setCurrentStateFromRedoStack() {
		if (!redoStack.isEmpty()) {
			stateObj = redoStack.pop();
			undoStack.push(new UIState(stateObj));		
		}
	}
	

	@Override
	public String undo() {
		String outputMsg = storage.undo();
		setCurrentStateFromUndoStack();
		return outputMsg;
	}

	private void setCurrentStateFromUndoStack() {
		if (!undoStack.isEmpty()) {
			stateObj = undoStack.pop();
			redoStack.push(new UIState(stateObj));
		}
	}

	
	@Override
	public String update(int taskId, String taskDescription, Date startDate, Date endDate) throws Exception {
		if (stateObj.displayType == ListType.FINISHED || stateObj.displayType == ListType.DELETED) {
			throw new Exception(EXCEPTION_CANNOT_UPDATE_FINISH_OR_DELETED_TASK);
		}

		Task taskToUpdate = getTask(taskId);
		Task newTask = Util.createTask(taskDescription, startDate, endDate);
		String outputMsg = storage.update(taskToUpdate, newTask);
		addCurrentStateToUndoStackAndClearRedoStack();
		updateTaskList();

		stateObj.idNewTask = getNewTaskId(newTask);
		return outputMsg;
	}

	@Override
	public String home() {
		stateObj.setDefault();
		return MESSAGE_HOME;
	}

	@Override
	public String restore(int taskId) throws Exception {
		if (stateObj.displayType == ListType.NORMAL) {
			throw new Exception("Cannot restore an undeleted/ unfinished task!");
		}

		Task taskToRestore = getTask(taskId);
		String outputMsg = storage.restore(taskToRestore);
		addCurrentStateToUndoStackAndClearRedoStack();

		return outputMsg;
	}

	@Override
	public String viewFinished() {
		stateObj.setDefault();
		stateObj.displayType = ListType.FINISHED;
		return MESSAGE_FINISHED_LIST;
	}

	@Override
	public String viewDeleted() {
		stateObj.setDefault();
		stateObj.displayType = ListType.DELETED;
		return MESSAGE_DELETED_LIST;
	}

	@Override
	public String getTaskStringToUserInputBoxById(int taskId) throws Exception {
		Task taskToBeUpdated = getTask(taskId);
		stateObj.inputBox = getTaskToBeUpdated(taskToBeUpdated, taskId);
		stateObj.idNewTask = -1;
		return String.format(MESSAGE_TASK_FOUND, taskId);
	}

	protected String getTaskToBeUpdated(Task taskToBeUpdated, int taskId) {
		String taskDescription = taskToBeUpdated.getDescription();
		Date startDate = taskToBeUpdated.getStartDate();
		Date endDate = taskToBeUpdated.getEndDate();
		return getUserEditableTaskString(taskId, taskDescription, startDate, endDate);
	}

	private String getUserEditableTaskString(int taskId, String taskDescription, Date startDate, Date endDate) {
		String taskString = null;
		if (endDate == null) {
			taskString = taskDescription;
		} else if (startDate == null) {
			String endDateString = Util.getDateString(endDate);
			taskString = taskDescription + " by " + endDateString;
		} else {
			String startDateString = Util.getDateString(startDate);
			String endDateString = Util.getDateString(endDate);
			taskString = taskDescription + " from " + startDateString + " to " + endDateString;
		}
		return String.format(USER_EDITABLE_TASK_FORMAT, taskId, taskString);
	}

	@Override
	public List<Task> getTaskList() throws IOException {
		updateTaskList();
		return userTaskList;
	}

	@Override
	public String find(Date filterDate) throws IOException {
		assert(filterDate != null);
		stateObj.filterDate = filterDate;
		stateObj.filterList = null;
		return String.format(MESSAGE_FIND_BY_DATE, Util.getDateString(filterDate));
	}

	
	@Override
	public String readFromFilePath(String pathName) {
		assert(pathName != null);
		String feedback = storage.get(pathName);
		clearUndoAndRedoStack();

		stateObj.setDefault();
		return feedback;
	}

	@Override
	public String saveFileAt(String pathName) {
		assert(pathName != null);
		String feedback = storage.path(pathName);
		clearUndoAndRedoStack();

		stateObj.setDefault();
		return feedback;
	}

	private void clearUndoAndRedoStack() {
		undoStack.clear();
		redoStack.clear();
	}

	
	@Override
	public String getCurrentFilePath() {
		return String.format(MESSAGE_READING_FROM_PATH, storage.getCurrentFilePath());
	}

	/**
	 * Used by add and update method. Returns ID of task added for UI to highlight
	 * when that task is added to the list.
	 * 
	 * @param newTask
	 * 			New task that was added.
	 * @return	ID of task added.
	 * @throws IOException
	 */
	private int getNewTaskId(Task newTask) throws IOException {
		updateTaskList();
		return userTaskList.indexOf(newTask);
	}

	/**
	 * Updates the user task list.
	 * 
	 * @throws IOException
	 */
	private void updateTaskList() throws IOException {
		userTaskList = taskFilter.getUserTaskList(stateObj);
	}

	
	/**
	 * Adds current UIState to undoStack and clear redoStack
	 */
	private void addCurrentStateToUndoStackAndClearRedoStack() {
		undoStack.push(new UIState(stateObj));
		redoStack.clear();
		if (undoStack.size() > UNDO_STACK_SIZE) {
			undoStack.removeLast();
		}
	}
}
```
###### src\doordonote\logic\Logic.java
``` java

package doordonote.logic;

import java.io.IOException;
import java.util.List;

import doordonote.command.Command;
import doordonote.commandfactory.CommandFactory;
import doordonote.common.Task;

```
###### src\doordonote\logic\Logic.java
``` java

/**
 * Entry to the Logic component.
 * 
 * @author yunpeng
 *
 */
public class Logic implements UIToLogic {
	protected static final String EXCEPTION_CORRUPTED_FILE = "Storage file is corrupted. Use 'readfrom' or 'save' to read from or create new file";

	protected CommandFactory cmdFactory = null;
	protected CommandToController controller = null;

	public Logic() {
		cmdFactory = new CommandFactory();
		controller = new Controller();
	}

	@Override
	public String parseAndExecuteCommand(String userInput) throws Exception {
		Command cmd = cmdFactory.parse(userInput);
		String feedback;
		try {
			feedback = cmd.execute(controller);
		} catch (IOException e) {
			throw new IOException(EXCEPTION_CORRUPTED_FILE);
		}
		return feedback;
	}

	@Override
	public UIState getState() {
		return controller.getState();
	}

	@Override
	public List<Task> getTasks() throws IOException {
		List<Task> taskList = null;
		try {
			taskList = controller.getTaskList();
		} catch (IOException e) {
			 throw new IOException(EXCEPTION_CORRUPTED_FILE);
		}
		return taskList;
	}

}
```
###### src\doordonote\logic\TaskFilter.java
``` java

/**
 * {@code TaskFilter} filters the tasks visible to users based on 
 * the UIState object.
 * 
 * @author yunpeng
 *
 */
public class TaskFilter {
	
	protected Storage storage = null;
	protected ArrayList<Task> fullTaskList = null;
	
	protected TaskFilter(Storage storage) {
		this.storage = storage;
		try {
			fullTaskList = storage.readTasks();
		} catch (IOException e) {
			fullTaskList = new ArrayList<Task>();
		}
	}
	
	
	/**
	 * Filters the full task list based on the stateObj
	 * 
	 * @param stateObj
	 * @return user task list based on the UIState object.
	 * @throws IOException
	 */
	public List<Task> getUserTaskList(UIState stateObj) throws IOException {
		fullTaskList = storage.readTasks();
		assert (fullTaskList != null);
		List<Task> userTaskList = filterTaskByDisplayType(stateObj);
		return filterByDateAndKeywords(stateObj, userTaskList);
	}

	private List<Task> filterByDateAndKeywords(UIState stateObj, List<Task> userTaskList) {
		if (stateObj.filterDate != null) {
			return filterByDate(userTaskList, stateObj.filterDate);
		} else if (stateObj.filterList != null) {
			return filterByKeywords(userTaskList, stateObj.filterList);
		} else {
			return userTaskList;
		}
	}
	
	private List<Task> filterTaskByDisplayType(UIState stateObj) throws IOException {
		List<Task> userTaskList;
		switch (stateObj.displayType) {
		case DELETED :
			userTaskList = getDeletedTasks();
			break;
		case FINISHED :
			userTaskList = getFinishedTasks();
			break;
		case NORMAL :
			// fallthrough
		default :
			userTaskList = getUnfinishedTasks();
		}
		return userTaskList;
	}
	
	protected List<Task> filterByDate(List<Task> unfilteredUserTaskList, Date filterDate) {
		List<Task> userTaskList = new ArrayList<Task>();
		for (Task task : unfilteredUserTaskList) {
			if (task.getEndDate() != null && task.getEndDate().after(filterDate)) {
				userTaskList.add(task);
			}
		}
		return userTaskList;		
	}

	protected List<Task> filterByKeywords(List<Task> unfilteredUserTaskList, List<String> filterList) {
		List<Task> tempList = null;
		List<Task> userTaskList = unfilteredUserTaskList;
		for (String keyword : filterList) {
			tempList = new ArrayList<Task>();
			for (Task task : userTaskList) {
				if (task.getDescription().toLowerCase().contains(keyword.toLowerCase())) {
					tempList.add(task);
				}
			}
			userTaskList = tempList;
		}
		return userTaskList;
	}

	private List<Task> getUnfinishedTasks() throws IOException {
		return storage.readTasks();
	}

	private List<Task> getFinishedTasks() throws IOException {
		return storage.readDoneTasks();
	}

	private List<Task> getDeletedTasks() throws IOException {
		return storage.readDeletedTasks();
	}
	
}
	




```
###### src\doordonote\logic\UIState.java
``` java

public class UIState {
	
	// Type of display
	public enum ListType {
	    DELETED, FINISHED, NORMAL
	}
	
	
	// Fills the user inputBox with this String.
	// Only used by the update method in Controller
	protected String inputBox = null;
	
	// Determines the type of helpBox to display
	protected String helpBox = null;
	
	// Determines the type of Tasks to display
	protected ListType displayType = null;
	
	// Stores the id of a new task. UI will use this id 
	// to highlight newly added tasks
	protected int idNewTask = -1;
	
	// A list of words used to filter the task. Set by the find
	// find method in controller
	protected List<String> filterList = null;
	
	// Filters and displays the list of tasks that ends after
	// this Date
	protected Date filterDate = null;
	
	public UIState() {
		setDefault();
	}
	
	/**
	 * Used to clone a UIState object
	 * 
	 * @param 	other
	 * 			The UIState object to be cloned.
	 */
	public UIState(UIState other) {
		inputBox = other.inputBox;
		displayType = other.displayType;
		helpBox = other.helpBox;
		idNewTask = other.idNewTask;
		filterList = other.filterList;
		filterDate = other.filterDate;
	}
	
	public int getIdNewTask() {
		return idNewTask;
	}

	public ListType getDisplayType() {
		return displayType;
	}

	public String getInputBox() {
		return inputBox;
	}
	
	public String getHelpBox() {
		return helpBox;
	}
	
	/**
	 * Gets a suitable title based on the current state
	 * of the UIState 
	 * 
	 * @return the title that should be displayed
	 */
	public String getTitle() {
		String title = "";
		title = getTitleBasedOnDisplayType();
		if (filterDate != null) {
			return getTitleForFilterDate(title);
		} else if (filterList != null && !filterList.isEmpty()) {
			return getTitleForFilterList(title);
		} else {
			return title;
		}
	}

	private String getTitleBasedOnDisplayType() {
		String title;
		switch (displayType) {
		case FINISHED :
			title = "Finished Tasks";
			break;
		case DELETED :
			title = "Deleted Tasks";
			break;
		case NORMAL :
			// fall through
		default :
			title = "Home";
		}
		return title;
	}

	private String getTitleForFilterDate(String title) {
		title += "- Tasks that ends after: ";
		title += Util.getDateString(filterDate);
		return title;
	}

	private String getTitleForFilterList(String title) {
		title += "- Filter by: ";
		for (String word : filterList) {
			title += word + ", ";
		}
		return title;
	}

	
	/**
	 * Removes states that should not persist
	 */
	protected void clearTempState() {
		inputBox = "";
		helpBox = null;
		idNewTask = -1;
	}
	
	/**
	 * Sets the default state
	 */
	protected void setDefault() {
		inputBox = "";
		displayType = ListType.NORMAL;
		helpBox = null;
		idNewTask = -1;
		filterList = null;
		filterDate = null;
	}

	/* 
	 * equals() is used only in testing
	 */
	public boolean equals(Object other) {
	    if (other == null) {
	        return false;
	    }
	    if (other == this) {
	    	return true;
	    }

        if (other instanceof UIState) {
        	UIState otherUIState = (UIState)other;
        	if (this.inputBox == otherUIState.inputBox && 
        		this.helpBox == otherUIState.helpBox &&
        		this.displayType == otherUIState.displayType &&
	        	this.idNewTask == otherUIState.idNewTask &&
	        	this.filterList == otherUIState.filterList &&
	        	this.filterDate == otherUIState.filterDate) {
        		return true;
        	}
        }
        return false;
	}
	
	/*
	 * hashCode method is implemented only to be consistent with the equals() method
	 * For using UIState class in any hash methods (e.g. storing it in a Hashmap),
	 * a better implementation of hashCode should be used.
	 */
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((inputBox == null) ? 0 : inputBox.hashCode());
		result = prime * result + ((helpBox == null) ? 0 : helpBox.hashCode());
		result = prime * result + idNewTask;
		result = prime * result + ((filterList == null) ? 0 : filterList.hashCode());
		result = prime * result + ((filterDate == null) ? 0 : filterDate.hashCode());
		return result;
	}
}
	
```
###### src\doordonote\logic\UIToLogic.java
``` java

public interface UIToLogic {
	/** 
	 * Gets a list of Tasks filtered based on the UIState object.
	 * Tasks in the list is sorted.
	 * 
	 * @return A sorted {@code List<Task>}
	 * @throws IOException 
	 */
	List<Task> getTasks() throws IOException;
	
	/**
	 * @param 	userInput
	 * 			User input commands to be parsed and interpreted.
	 * @return	Feedback message for users to know what has been executed.
	 * @throws 	Exception
	 * 			Exception contains error messages to inform users that their
	 * 			input is not executed properly.
	 */
	String parseAndExecuteCommand(String userInput) throws Exception;
	
	/**
	 * 
	 * @return UIState object that will be interpreted by UI
	 */
	UIState getState();
}
```
###### test\doordonote\commandfactory\CommandFactoryTest.java
``` java

package doordonote.commandfactory;

import static org.junit.Assert.assertEquals;

import org.junit.Test;

public class CommandFactoryTest {
//	private CommandFactory cmdFactory = new CommandFactory();

	@Test
	public void getCommandTypeTest() {
		assertEquals("getCommandType should be case insensitive", 
					 "add", 
					 CommandFactory.getCommandType("AdD list of statements"));
		
		assertEquals("getCommandType should be robust to leading spaces",
				 	 "test", 
				 	 CommandFactory.getCommandType("  test  list of "));
		assertEquals("getCommandType should be return empty string for blank strings",
			 	 	 "", 
			 	 	 CommandFactory.getCommandType("   "));	
	}
	
	@Test
	public void parseTest() {
		
	}

}
```
###### test\doordonote\commandfactory\DateParserTest.java
``` java

package doordonote.commandfactory;

import static org.junit.Assert.assertEquals;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.joda.time.DateTime;
import org.junit.Test;

public class DateParserTest {
	
	private DateParser parser = new DateParser();

	
	@Test
	public void parseAndGetDateListTest() {
		DateTime dt1 = new DateTime(2013, 1, 15, 8, 0, 0, 0);
		DateTime dt2 = new DateTime(2015, 3, 30, 8, 0, 0, 0);
	    Date jdkDate1 = dt1.toDate();
	    Date jdkDate2 = dt2.toDate();
	    List<Date> createdDateList = new ArrayList<Date>();
	    createdDateList.add(jdkDate1);
	    createdDateList.add(jdkDate2);
	    List<Date> parsedDateList = parser.parseAndGetDateList("from 15 jan 2013 to 30 march  8");
        
	    assertEquals("Parser should get list of 2 dates", createdDateList, parsedDateList);
	    
	    createdDateList.remove(1);
	    //check that parser only parse one date when no connecting words like "to" is used
	    assertEquals("Parser should get only one valid date without 'to'", 
	    			 createdDateList, 
	    			 parser.parseAndGetDateList("from 15 jan 2013 30 march  7.45"));
	    assertEquals("Parser should return null if no dates are found", 
	    			 null, 
	    			 parser.parseAndGetDateList("do research on database"));


	}
	
	@Test
	public void parseTest() {
		// Creates DateTime object with information like year, month,
        // day, hour, minute, second and milliseconds
		DateTime dt1 = new DateTime(2015, 11, 24, 8, 0, 0, 0);
	    Date jdkDate1 = dt1.toDate();
	    
		DateTime dt2 = new DateTime(2015, 4, 8, 12, 0, 0, 0);
	    Date jdkDate2 = dt2.toDate();
        assertEquals("Parser should return default time at 8am", jdkDate1, parser.parse("nov 24"));
        assertEquals("Parser should be able to deal with leading/ trailing space", 
        			 jdkDate2, 
        			 parser.parse("april 8   12pm"));
        assertEquals("Parser should be able to take empty strings", null, parser.parse(""));
	}

}
```
###### test\doordonote\logic\ControllerTest.java
``` java

package doordonote.logic;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.joda.time.DateTime;
import org.junit.Before;
import org.junit.Test;

import doordonote.common.Util;
import doordonote.logic.UIState.ListType;
import doordonote.storage.DuplicateTaskException;
import doordonote.storage.Storage;

public class ControllerTest {
	private Controller controller = null;
	private Storage storage = null;
	
	@Before
	public void setUp() throws Exception {
		
		// Adds 3 tasks to StorageStub obj
		String description1 = "Task 1";
		DateTime startDt1 = new DateTime(2015, 11, 30, 8, 0, 0, 0);
		DateTime endDt1 = new DateTime(2015, 11, 30, 8, 0, 0, 0);

		String description2 = "Task 2";
		DateTime endDt2 = new DateTime(2015, 11, 30, 8, 0, 0, 0);
		
		String description3 = "Task 3";
		
		storage = new StorageStub();
		storage.add(Util.createTask(description1, startDt1.toDate(), endDt1.toDate()));
		storage.add(Util.createTask(description2, null, endDt2.toDate()));
		storage.add(Util.createTask(description3, null, null));
		
		controller = new Controller(storage);
	}
	
	@Test
	public void addTest() throws IOException, DuplicateTaskException {
		String description = "task to be added";
		// Creates DateTime object with information like year, month,
        // day, hour, minute, second and milliseconds
		DateTime startDt = new DateTime(2015, 11, 30, 8, 0, 0, 0);
		DateTime endDt = new DateTime(2015, 11, 30, 8, 0, 0, 0);
		String feedBack = null;

		controller.stateObj.displayType = ListType.DELETED;
		UIState testStateObj1 = new UIState();
		testStateObj1.idNewTask = 3;
		
		feedBack = controller.add(description, 
								  startDt.toDate(), 
								  endDt.toDate());

		
		// Testing if add is called and if ListType is set to Normal
		assertEquals("Test if storage.add() is called", "Add is called", feedBack);
		assertEquals("Test if UIState is updated correctly", testStateObj1, controller.getState());
		
		UIState testStateObj2 = new UIState();
		List<String> filterList = new ArrayList<String>();
		filterList.add("3");
		testStateObj2.filterList = filterList;
		testStateObj2.idNewTask = 1;
		controller.stateObj.filterList = filterList;
		controller.getTaskList();
		controller.add("test task 3", null, null);
		
		
		// Testing if add maintains the same filterList if task added
		// can be seen from current list
		assertEquals("Test if UIState maintains the filter criteria", testStateObj2, controller.getState());
	}
	
	@Test
	public void deleteTest() throws Exception {
		String feedBack1 = controller.delete(1);
		UIState testStateObj1 = new UIState();
		assertEquals("Test if storage.delete() is called", "Delete is called", feedBack1);
		assertEquals("Test if UISTATE is updated correctly", testStateObj1, controller.getState());

		controller.stateObj.displayType = ListType.DELETED;
		String feedBack2 = controller.delete(1);
		UIState testStateObj2 = new UIState();
		testStateObj2.displayType = ListType.DELETED;
		assertEquals("Test if storage.remove() is called", "Remove is called", feedBack2);
		assertEquals("Test if UISTATE is updated correctly", testStateObj2, controller.getState());
		
		
	}
	
	@Test
	public void displayDeletedTest() throws IOException {
		UIState testStateObj = new UIState();
		testStateObj.displayType = ListType.DELETED;
		controller.viewDeleted();
		assertEquals("Test if UIState is updated correctly", 
			 	 	 testStateObj, 
			 	 	 controller.getState());
	}
	
	@Test
	public void displayFinishedTest() throws IOException {
		UIState testStateObj = new UIState();
		testStateObj.displayType = ListType.FINISHED;
		controller.viewFinished();
		assertEquals("Test if UIState is updated correctly", 
			 	 	 testStateObj, 
			 	 	 controller.getState());
	}
	
	@Test
	public void findDateTest() throws IOException {
		DateTime startDt = new DateTime(2015, 9, 30, 0, 0, 0, 0);
		Date startDate = startDt.toDate();
		controller.find(startDate);
		UIState testStateObj = new UIState();
		testStateObj.filterDate = startDate;
		
		
		assertEquals("Test if UIState is updated correctly", 
				 	 testStateObj, 
				 	 controller.getState());
	}
	
	@Test
	public void finishTest() throws Exception {
		String feedBack1 = controller.finish(1);
		UIState testStateObj1 = new UIState();
		
		assertEquals("Test if storage.finish() is called", "Finish is called", feedBack1);
		assertEquals("Test if UISTATE is updated correctly", testStateObj1, controller.getState());
		
		controller.stateObj.displayType = ListType.FINISHED;
		try {
			controller.finish(1);
			fail("Exception should have been thrown");
		} catch (Exception e) {
			assertEquals("Test if exception displays the right msg", 
						 "Task is already finished!", 
						 e.getMessage());
		}

	}
	
	@Test
	public void helpTest() {
		controller.help();
		
		controller.help("test");
		controller.help("add");
	}
	
	@Test
	public void homeTest() throws IOException {
		controller.viewDeleted(); // Change the display type
		String homeMsg = controller.home();
		UIState testStateObj = new UIState();
		
		assertEquals("Test if home() return msg is correct", 
					 "Displaying all unfinished task(s)", 
					 homeMsg);
		assertEquals("Test if UIState is updated correctly", 
					 testStateObj, 
					 controller.getState());
	}
	

}
```
###### test\doordonote\logic\LogicTest.java
``` java

public class LogicTest {
	private static String currentPath = null;
	private static Storage testStorage = null;
	private UIToLogic logic = null;
	private List<Task> testUnfinishedTaskList = null;
	private List<Task> testFinishedTaskList = null;

	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		testStorage = StorageHandler.getInstance();
		currentPath = testStorage.getCurrentFilePath();
	}

	@Before
	public void setUp() throws Exception {
		DateTime dt1 = new DateTime(2015, 11, 30, 8, 0, 0, 0);

		Task floatingTask1 = new FloatingTask("Watch LOTR");
		Task floatingTask2 = new FloatingTask("Read Starwars");
		Task deadlineTask = new DeadlineTask("Finish Report", dt1.toDate());

		
		// Initialize the storage path
		testStorage.path("test");
		logic = new Logic();
		testStorage.clear();
		testStorage.add(floatingTask1);
		testStorage.add(floatingTask2);
		testStorage.add(deadlineTask);
		testStorage.finish(floatingTask2);
		logic.getTasks();
		
		testUnfinishedTaskList = new ArrayList<Task>();
		testFinishedTaskList = new ArrayList<Task>();

		testUnfinishedTaskList.add(deadlineTask);
		testUnfinishedTaskList.add(floatingTask1);
		// Tasklist:
		// Finish report
		// watch LOTR
		
		testFinishedTaskList.add(floatingTask2);

	}

	@After
	public void deleteTestFiles() {
		boolean success = new File("test.json").delete();
		System.out.println("File deleted = " + success);
	}

	@AfterClass
	public static void restorePath() {
		testStorage.get(currentPath);
	}

	@Test
	public void addTest() throws Exception {
		String feedback = logic.parseAndExecuteCommand("add attend meeting from 16 Dec 4pm to 6pm");
		assertEquals("Check that feedback for adding a task is correct", "Task \"attend meeting\" added", feedback);
		UIState actualState = logic.getState();
		UIState testState = new UIState();
		testState.idNewTask = 1; // Newly added Task should have a TaskId of 2
									// (index of 1 in List)
		assertEquals("Check that UIState is correct", testState, actualState);

		DateTime dt1 = new DateTime(2015, 12, 16, 16, 0, 0, 0);
		DateTime dt2 = new DateTime(2015, 12, 16, 18, 0, 0, 0);

		Task newlyAddedTask = new EventTask("attend meeting", dt1.toDate(), dt2.toDate());

		testUnfinishedTaskList.add(1, newlyAddedTask);

		assertEquals("Check that task list is correct", testUnfinishedTaskList, logic.getTasks());

	}

	@Test
	public void addExceptionTest() {
		try {
			logic.parseAndExecuteCommand("add Watch LOTR");
		} catch (Exception e) {
			assertEquals("Check that exception message is correct for repeated task", "Duplicate Task!",
					e.getMessage());
		}

		try {
			logic.parseAndExecuteCommand("   ");
		} catch (Exception e) {
			assertEquals("Check that exception message is correct for blank inputs task",
					"add command requires arguments. Type 'help add' for more details.", e.getMessage());
		}
	}

	@Test
	public void deleteTest() throws Exception {
		String feedback = logic.parseAndExecuteCommand("del 2");
		
		assertEquals("Check that feedback is correct", "Task \"Watch LOTR\" deleted", feedback);
		
		assertEquals("Check that UIState is correct", new UIState(), logic.getState());
		assertEquals("Check that feedback is correct", "Task \"Watch LOTR\" deleted", feedback);
		
		Task deletedTask = new FloatingTask("Watch LOTR");
		testUnfinishedTaskList.remove(deletedTask);
		assertEquals("Check that unfinished Task list is correct", testUnfinishedTaskList, logic.getTasks());

		
		logic.parseAndExecuteCommand("view deleted");
		List<Task> deletedTaskList = new ArrayList<Task>();
		deletedTask.setDeleted();
		deletedTaskList.add(deletedTask);
		assertEquals("Check that deleted Task list is correct", deletedTaskList, logic.getTasks());
	}
	
	@Test
	public void finishTest() throws Exception {
		String feedback = logic.parseAndExecuteCommand("fin 2");
		
		assertEquals("Check that UIState is correct", new UIState(), logic.getState());
		assertEquals("Check that feedback is correct", "Marked Task \"Watch LOTR\" as done", feedback);
		
		Task deletedTask = new FloatingTask("Watch LOTR");
		testUnfinishedTaskList.remove(deletedTask);
		assertEquals("Check that unfinished Task list is correct", testUnfinishedTaskList, logic.getTasks());

		
		logic.parseAndExecuteCommand("view finished");
		assertEquals("Check that finished Task list has 2 Tasks", 2, logic.getTasks().size());
	}
	
}
```
###### test\doordonote\logic\StorageStub.java
``` java

package doordonote.logic;

import java.io.IOException;
import java.util.ArrayList;

import doordonote.common.Task;
import doordonote.storage.Storage;

public class StorageStub implements Storage {
	private ArrayList<Task> taskList = null;
	
	public StorageStub() {
		 taskList = new ArrayList<Task>();
	}
	
	@Override
	public String path(String location) {
		return "Path is called";
	}

	@Override
	public String get(String location) {
		return "Get is called";
	}

	@Override
	public String add(Task task) {
		taskList.add(task);
		return "Add is called";
	}

	@Override
	public String update(Task oldTask, Task newTask) {
		taskList.remove(oldTask);
		taskList.add(newTask);
		return "Update is called";
	}

	@Override
	public String delete(Task taskToDelete) {
		taskList.remove(taskToDelete);
;		return "Delete is called";
	}

	@Override
	public String remove(Task taskToRemove) throws IOException {
		taskList.remove(taskToRemove);
;		return "Remove is called";
	}

	@Override
	public ArrayList<Task> readTasks() throws IOException {
		return taskList;
	}

	@Override
	public String undo() {
		return "Undo is called";
	}

	@Override
	public String redo() {
		return "Redo is called";
	}

	@Override
	public String restore(Task task) throws IOException {
		return "Restore is called";
	}

	@Override
	public String finish(Task task) throws IOException {
		return "Finish is called";
	}

	
	// Not used
	@Override
	public String notFinish(Task task) throws IOException {
		// TODO Auto-generated method stub
		return null;
	}
	

	@Override
	public ArrayList<Task> readDeletedTasks() throws IOException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public ArrayList<Task> readDoneTasks() throws IOException {
		// TODO Auto-generated method stub
		return null;
	}
	
	@Override
	public String clear() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String getCurrentFilePath() {
		// TODO Auto-generated method stub
		return null;
	}

}
```
