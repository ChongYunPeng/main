# A0131436N
###### src\doordonote\command\AddCommand.java
``` java

/**
 * @author yunpeng
 *
 */
public class AddCommand implements Command {
	protected String taskDescription = null;
	protected Date startDate = null;
	protected Date endDate = null;
	
	/**
	 * @param 	taskDescription 
	 * 			the description of the task to be added
	 * @param 	startDate
	 * 			The start date of the event. A null value indicates this task is not an event
	 * @param 	endDate
	 * 			The end date of the event. A null value indicates this task is not a deadline
	 */
	public AddCommand(String taskDescription, Date startDate, Date endDate) {
		// AddHandler should have checked that task is not null and not empty
		assert(taskDescription != null && !Util.isBlankString(taskDescription));
		
		this.taskDescription = taskDescription;
		this.startDate = startDate;
		this.endDate = endDate;
	}
	
	@Override
	public String execute(CommandToController controller) throws IOException, DuplicateTaskException {
		assert(controller != null);
		return controller.add(taskDescription, startDate, endDate);
	}
}
```
###### src\doordonote\command\Command.java
``` java

/**
 * Interface where new concrete Command implementations should inherit from.
 * 
 */
public interface Command {
	/**
	 * Executes this command
	 * 
	 * @param 	controller
	 * 			methods in the controller will be called
	 * @return 	feedback that gives information about the outcome of the execution of the command
	 * @throws 	IOException 
	 * @throws 	Exception 
	 */
	String execute(CommandToController controller) throws IOException, Exception;
}
```
###### src\doordonote\command\DeleteCommand.java
``` java

/**
 * @author yunpeng
 *
 */
public class DeleteCommand implements Command {
	int taskID = -1;
	
	/**
	 * @param 	taskID
	 * 			This is the ID of the task users will see in the UI.
	 */
	public DeleteCommand(int taskID) {
		// DeleteHandler should have checked that taskID is more than zero
		assert(taskID > 0);
		this.taskID = taskID;
	}

	@Override
	public String execute(CommandToController controller) throws Exception {
		return controller.delete(taskID);
	}

}
```
###### src\doordonote\command\FindCommand.java
``` java

/**
 * @author yunpeng
 *
 */
public class FindCommand implements Command {
	protected List<String> keywords = null;
	
	/**
	 * @param 	keywords
	 * 		  	Filters user task list by only tasks that contains (not case sensitive) 
	 * 			words in {@code keywords}.
	 */
	public FindCommand(List<String> keywords) {
		assert(keywords != null);
		this.keywords = keywords;
	}

	@Override
	public String execute(CommandToController controller) throws IOException {
		return controller.find(keywords);
	}

}
```
###### src\doordonote\command\FindDateCommand.java
``` java

/**
 * @author yunpeng
 *
 */
public class FindDateCommand implements Command {
	protected Date startDate = null;
	
	/**
	 * @param 	startDate
	 * 			Filters user task list by only tasks that end after {@code startDate}.
	 * 			Floating task should not be displayed
	 */
	public FindDateCommand(Date startDate) {
		assert(startDate != null);
		this.startDate = startDate;
	}

	@Override
	public String execute(CommandToController controller) throws IOException, Exception {
		return controller.find(startDate);
	}
}
```
###### src\doordonote\command\FinishCommand.java
``` java

/**
 * @author yunpeng
 *
 */
public class FinishCommand implements Command {
	protected int taskIdToFinish = -1;
	
	/**
	 * Marks a task as finished.
	 * 
	 * @param 	taskIdToFinish
	 * 			This is the ID of the task users will see in the UI.
	 */
	public FinishCommand(int taskIdToFinish) {
		assert(taskIdToFinish > 0);
		this.taskIdToFinish = taskIdToFinish;
	}

	@Override
	public String execute(CommandToController controller) throws Exception {
		return controller.finish(taskIdToFinish);
	}

}
```
###### src\doordonote\command\GetPathCommand.java
``` java

/**
 * This Command display the path of the storage file to the user
 * 
 * @author yunpeng
 *
 */
public class GetPathCommand implements Command {

	@Override
	public String execute(CommandToController controller) throws IOException, Exception {
		return controller.getCurrentFilePath();
	}

}
```
###### src\doordonote\command\HelpCommand.java
``` java

/**
 *	Command to display help to users.
 */
public class HelpCommand implements Command {
	protected String commandType = null;
	
	/**
	 * @param 	commandType
	 * 			The command user needs help for.
	 */
	public HelpCommand(String commandType) {
		this.commandType = commandType; 
	}
	
	public HelpCommand() {
		
	}

	@Override
	public String execute(CommandToController controller) {
		if (commandType == null) {
			return controller.help();
		} else {
			return controller.help(commandType);
		}
	}

}
```
###### src\doordonote\command\HomeCommand.java
``` java

/**
 * @author yunpeng
 * This command is used to display the default task lists.
 *
 */
public class HomeCommand implements Command{
	@Override
	public String execute(CommandToController controller) throws IOException {
		assert(controller != null);
		return controller.home();
	}
}
```
###### src\doordonote\command\ReadPathCommand.java
``` java

/**
 * 
 * This {@code Command} is used to read from a storage file at the user input path. 
 *
 */
public class ReadPathCommand implements Command {
	protected String pathName = null;
	
	/**
	 * @param 	path
	 * 			File path of the .json storage file in the file system.
	 * 			File path can be absolute or relative to current folder.
	 */
	public ReadPathCommand(String path) {
		assert(path != null);
		pathName = path;
	}

	@Override
	public String execute(CommandToController controller) throws IOException, Exception {
		return controller.readFromFilePath(pathName);
	}

}
```
###### src\doordonote\command\RedoCommand.java
``` java

/**
 * @author yunpeng
 *	Redo the effects made by {@code UndoCommand}
 */
public class RedoCommand implements Command {
	@Override
	public String execute(CommandToController controller) throws IOException {
		return controller.redo();
	}

}
```
###### src\doordonote\command\RestoreCommand.java
``` java

/**
 * @author yunpeng
 *
 */
public class RestoreCommand implements Command {
	protected int indexToRestore = -1;

	/**
	 * @param 	indexToRestore
	 * 			Task ID to be restored.
	 * 		 	Task restored is treated as undeleted and unfinished
	 */
	public RestoreCommand(int indexToRestore) {
		assert(indexToRestore > 0);
		this.indexToRestore = indexToRestore;
	}

	@Override
	public String execute(CommandToController controller) throws Exception {
		return controller.restore(indexToRestore);
	}

}
```
###### src\doordonote\command\SetPathCommand.java
``` java

/**
 * Command used to save a storage file in a particular path in the file system.
 * If a file of the same name already exists, simply read from the existing file. 
 *
 */
public class SetPathCommand implements Command {
	protected String pathName = null;
	
	/**
	 * @param 	path
	 * 			Location on the file system to create .json storage file.
	 * 			If file already exists, simply read from it.
	 */
	public SetPathCommand(String path) {
		pathName = path;
	}

	@Override
	public String execute(CommandToController controller) throws IOException, Exception {
		return controller.saveFileAt(pathName);
	}

}
```
###### src\doordonote\command\UndoCommand.java
``` java

/**
 * @author yunpeng
 *
 *	Undo the previous action that modified the storage file.
 *	(E.g. AddCommand/ DeleteCommand/ UpdateCommand)
 */
public class UndoCommand implements Command {
	@Override
	public String execute(CommandToController controller) throws IOException {
		return controller.undo();
	}

}
```
###### src\doordonote\command\UpdateCommand.java
``` java

/**
 * @author yunpeng
 */
public class UpdateCommand implements Command {
	protected int taskID = -1;
	protected String taskDescription = null;
	protected Date startDate = null;
	protected Date endDate = null;
	
	/**
	 * @param 	taskID
	 * 			Task ID to be updated. This task will be deleted and replaced by a new Task.
	 * @param 	taskDescription
	 * 			Task description that will replace the old task.
	 * @param 	startDate
	 * @param 	endDate
	 */
	public UpdateCommand(int taskID, String taskDescription, Date startDate, Date endDate) {
		// UpdateHandler should have checked that taskID > 0
		this(taskID);
		// UpdateHandler should have checked that taskDescription is not null and not empty
		assert(taskID > 0);
		assert(taskDescription != null && !taskDescription.isEmpty()); 	
		
		this.taskDescription = taskDescription;
		this.startDate = startDate;
		this.endDate = endDate;
		this.taskID = taskID;
	}
	
	/**
	 * @param 	taskID
	 * 			Task ID to be updated.
	 * 			This constructor returns the details of the task to be updated to the
	 *			user's input box as a {@code String} so that users can more easily
	 *			modify the contents of the {@code Task}. 
	 *			The actual {@code Task} object is not modified.
	 * 			
	 */
	public UpdateCommand(int taskID) {
		// UpdateHandler should have checked that taskID > 0
		assert(taskID > 0); 
		this.taskID = taskID;
		this.taskDescription = null;
	}

	@Override
	public String execute(CommandToController controller) throws Exception {
		if (taskDescription == null) {
			return controller.getTaskStringById(this.taskID);
		}
		return controller.update(taskID, taskDescription, startDate, endDate);
	}
	



}
```
###### src\doordonote\command\ViewDeletedTaskCommand.java
``` java

/**
 * @author yunpeng
 * 
 * This {@code Command} displays a list of deleted {@code Task} to the user
 *
 */
public class ViewDeletedTaskCommand implements Command {
	
	@Override
	public String execute(CommandToController controller) throws IOException {
		return controller.viewDeleted();
	}

}
```
###### src\doordonote\command\ViewFinishedTaskCommand.java
``` java

/**
 * @author yunpeng
 *
 * This {@code Command} displays a list of finished {@code Task} to the user
 */
public class ViewFinishedTaskCommand implements Command {
	
	@Override
	public String execute(CommandToController controller) throws IOException {
		return controller.viewFinished();
	}

}
```
###### src\doordonote\commandfactory\AbstractAddCommandHandler.java
``` java

/**
 * Parses dates from user input String. Extended by AddCommand and UpdateCommand
 * 
 * @author yunpeng
 *
 */
public abstract class AbstractAddCommandHandler extends CommandHandler {
	protected static final String EXCEPTION_STARTDATE_AFTER_ENDDATE = "End date (%1$s) must be later than Start date (%2$s)";
	protected static final String EXCEPTION_TASK_TOO_LONG = "Task description is too long! Maximum number of characters is 500";
	
	private static final int MAX_TASK_DESCRIPTION_LENGTH = 500;

	protected DateParser dateParser = null;
	protected Date startDate = null;
	protected Date endDate = null;
	protected String taskDescription = null;

	public AbstractAddCommandHandler(String commandBody, DateParser dateParser, String cmdType) throws Exception {
		super(commandBody);
		if (Util.isEmptyOrNull(commandBody)) {
			throw new Exception(String.format(EXCEPTION_NO_ARGUMENT, cmdType));
		}
		this.dateParser = dateParser;
		initialiseParameters(commandBody);
	}

	/**
	 * Parses and sets the taskDescription, startDate and endDate field
	 * 
	 * @param commandBody
	 *            User input.
	 * @throws Exception
	 *             Throws exception if an event startDate is later than its
	 *             endDate.
	 */
	private void initialiseParameters(String commandBody) throws Exception {
		if (isProbablyEvent()) {
			setEventStartAndEndDate(commandBody);
		} else if (isProbablyDeadline()) {
			setDeadlineDate(commandBody);
		} else {
			taskDescription = commandBody;
		}
	}

	private void setDeadlineDate(String commandBody) {
		String endDateString = commandBody.substring(getDeadlineDateIndex());
		Date endDate = dateParser.parse(endDateString);

		if (endDate == null) {
			taskDescription = commandBody;
		} else {
			taskDescription = getTaskDescription(getDeadlineDateIndex());
			this.endDate = endDate;
		}
	}

	private void setEventStartAndEndDate(String commandBody) throws Exception {
		String dateString = commandBody.substring(getEventStartDateIndex());
		List<Date> dateList = dateParser.parseAndGetDateList(dateString);

		if (dateList == null || dateList.size() < 2) {
			taskDescription = commandBody;
		} else {
			taskDescription = getTaskDescription(getEventStartDateIndex());
			this.startDate = dateList.get(0);
			this.endDate = dateList.get(1);

			if (startDate.compareTo(endDate) >= 0) {
				throw new Exception(String.format(EXCEPTION_STARTDATE_AFTER_ENDDATE, Util.getDateString(endDate),
						Util.getDateString(startDate)));
			}
		}
	}

	protected Date getStartDate() {
		return startDate;
	}

	protected Date getEndDate() {
		return endDate;
	}

	private boolean isProbablyEvent() {
		return getEventStartDateIndex() > getDeadlineDateIndex();
	}

	private boolean isProbablyDeadline() {
		return getEventStartDateIndex() < getDeadlineDateIndex();
	}

	private int getEventStartDateIndex() {
		return commandBody.toLowerCase().lastIndexOf(" from ");
	}

	private int getDeadlineDateIndex() {
		return commandBody.toLowerCase().lastIndexOf(" by ");
	}

	private String getTaskDescription(int endIndex) {
		return commandBody.substring(0, endIndex).trim();
	}

	protected String getTaskDescription() throws Exception {
		if (taskDescription.length() > MAX_TASK_DESCRIPTION_LENGTH) {
			throw new Exception(EXCEPTION_TASK_TOO_LONG);
		}
		return taskDescription;
	}
}
```
###### src\doordonote\commandfactory\AddHandler.java
``` java

public class AddHandler extends AbstractAddCommandHandler {
	
	protected AddHandler(String commandBody, DateParser dateParser) throws Exception {
		super(commandBody, dateParser, "add");
	}

	@Override
	public Command generateCommand() throws Exception {
		String taskDescription = getTaskDescription();
		Date startDate = getStartDate();
		Date endDate = getEndDate();

		return new AddCommand(taskDescription, startDate, endDate);
	}

}
```
###### src\doordonote\commandfactory\CommandFactory.java
``` java

public class CommandFactory {
	DateParser dateParser;

	public CommandFactory() {
		dateParser = new DateParser();
	}

	public Command parse(String userInput) throws Exception {

		String trimmedInput = userInput.trim();
		String commandType = getCommandType(trimmedInput);
		String commandBody = Util.removeFirstWord(trimmedInput);
		CommandHandler handler = null;

		switch (commandType) {

		case "add" :
			handler = new AddHandler(commandBody, dateParser);
			break;

		case "delete" :
			// fallthrough
		case "del":
			handler = new DeleteHandler(commandBody);
			break;

		case "update" :
			handler = new UpdateHandler(commandBody, dateParser);
			break;

		case "undo" :
			handler = new UndoHandler(commandBody);
			break;

		case "redo" :
			handler = new RedoHandler(commandBody);
			break;

		case "find" :
			handler = new FindHandler(commandBody, dateParser);
			break;

		case "finish" :
			// fallthrough
		case "fin" :
			handler = new FinishHandler(commandBody);
			break;

		case "help" :
			handler = new HelpHandler(commandBody);
			break;
		case "home" :
			handler = new HomeHandler(commandBody);
			break;
		case "restore" :
			handler = new RestoreHandler(commandBody);
			break;
		case "view" :
			handler = new ViewHandler(commandBody);
			break;
		 case "readfrom" :
			 handler = new ReadPathHandler(commandBody);
			 break;
		 case "save" :
			 handler = new SetPathHandler(commandBody);
			 break;
		default:
			// treats user input as adding a new task by default if input does not match any command type
			handler = new AddHandler(trimmedInput, dateParser);
		}

		return handler.generateCommand();
	}

	protected static String getCommandType(String userCommand) {
		assert(userCommand != null);
		String commandType = Util.getFirstWord(userCommand).toLowerCase();
		return commandType;
	}


}
```
###### src\doordonote\commandfactory\CommandHandler.java
``` java

/**
 * Creates a concrete {@code Command} object. 
 * 
 * @author yunpeng
 *
 */
public abstract class CommandHandler {
	protected String commandBody = null;
	protected static final String EXCEPTION_NO_ARGUMENT = "%1$s command requires arguments. Type 'help %1$s' for more details.";
	protected static final String EXCEPTION_EXCESS_ARGUMENTS = "%1$s should not have any arguments. Type 'help %1$s' for more details.";
	protected static final String EXCEPTION_INVALID_TASK_ID_FORMAT = "%1$s expects a positive integer as Task ID. Type 'help %1$s' for more details.";
	protected static final String EXCEPTION_INVALID_TASK_ID_VALUE = "Task ID cannot be less than 1!";

	protected CommandHandler(String commandBody) {
		this.commandBody = commandBody;
	}

	public static int getTaskIdFromString(String taskIdString, String cmdType) throws Exception {
		int taskId;
		try {
			taskId = Integer.parseInt(taskIdString);
		} catch (NumberFormatException e) {
			throw new Exception(String.format(EXCEPTION_INVALID_TASK_ID_FORMAT, cmdType));
		}
		
		if (taskId <= 0) {
			throw new Exception(EXCEPTION_INVALID_TASK_ID_VALUE);
		}
		return taskId;
	}

	/**
	 * Generates a {@code Command} that will be executed.
	 * This method should be overridden by concrete {@code CommandHandler} class.
	 * 
	 * @return A {@code Command} that is to be executed.
	 * @throws NumberFormatException
	 * @throws Exception
	 */
	public abstract Command generateCommand() throws NumberFormatException, Exception;
}
```
###### src\doordonote\commandfactory\DateParser.java
``` java

/**
 * @author yunpeng
 * A natty date parser wrapper that sets the default time to 8am in the morning.
 * Parser only takes dates in American date format. E.g. 10/3 is parsed as 3 Oct
 */
public class DateParser {
	protected Parser natty = null;

	protected DateParser() {
		natty = new Parser();
    	BasicConfigurator.configure();
	}
	
	public Date parse(String input) {
		List<Date> dateList = parseAndGetDateList(input);
		if (dateList == null) {
			return null;
		} else {
			return dateList.get(0);
		}
	}
	
	public Date parse(String input, Date defaultTime) {
		List<Date> dateList = parseAndGetDateList(input, defaultTime);
		if (dateList == null) {
			return null;
		} else {
			return dateList.get(0);
		}
	}
	
	public List<Date> parseAndGetDateList(String input) {
		Date defaultDate = getDateTodayEightAm();
		return parseAndGetDateList(input, defaultDate);
	}

	private Date getDateTodayEightAm() {
		DateTime midnightToday = new DateTime().withTimeAtStartOfDay();
		DateTime eightAm = midnightToday.plusHours(8);
		Date defaultDate = eightAm.toDate();
		return defaultDate;
	}
	
	public List<Date> parseAndGetDateList(String input, Date defaultTime) {
		assert(input != null); // input should always be checked to be no null
		
		CalendarSource.setBaseDate(defaultTime);
		List<DateGroup> baseDateGroupList = natty.parse(input);
		if (baseDateGroupList.isEmpty()) {
			return null;
		}
		DateGroup baseDateGroup = baseDateGroupList.get(0);
		List<Date> dateList = baseDateGroup.getDates();
		return dateList;
	}
}
```
###### src\doordonote\commandfactory\DeleteHandler.java
``` java

public class DeleteHandler extends CommandHandler {
	
	protected DeleteHandler(String commmandBody) throws Exception {
		super(commmandBody);
		if (Util.isEmptyOrNull(commandBody)) {
			throw new Exception(String.format(EXCEPTION_NO_ARGUMENT, "delete"));
		}
	}

	@Override
	public Command generateCommand() throws Exception {
		int indexToDelete = getTaskIdFromString(commandBody, "delete");
		return new DeleteCommand(indexToDelete);	
	}

}
```
###### src\doordonote\commandfactory\FindHandler.java
``` java

/**
 * Generates command to filter user task list based on either Date or a list of keywords
 * 
 * @author yunpeng
 *
 */
public class FindHandler extends CommandHandler {
	protected DateParser dateParser = null; 
	
	protected FindHandler(String commmandBody, DateParser parser) throws Exception {
		super(commmandBody);
		if (Util.isEmptyOrNull(commandBody)) {
			throw new Exception(String.format(EXCEPTION_NO_ARGUMENT, "find"));
		}
		dateParser = parser;			
	}

	@Override
	public Command generateCommand() {
		String firstWord = Util.getFirstWord(commandBody).toLowerCase();
		if (firstWord.equals("from")) {
			Date defaultTime = setDateToTodayMidnight();
			Date startDate = dateParser.parse(commandBody, defaultTime);
			if (startDate != null) {
				return new FindDateCommand(startDate);
			}
		}
		
		String[] keywordsArray= commandBody.split("\\s+");
		List<String> keywords = Arrays.asList(keywordsArray);
		return new FindCommand(keywords);
	}

	private Date setDateToTodayMidnight() {
		DateTime midnightToday = new DateTime().withTimeAtStartOfDay();
		Date defaultTime = midnightToday.toDate();
		return defaultTime;
	}

}
```
###### src\doordonote\commandfactory\FinishHandler.java
``` java

public class FinishHandler extends CommandHandler {

	protected FinishHandler(String commmandBody) throws Exception {
		super(commmandBody);
		if (Util.isEmptyOrNull(commandBody)) {
			throw new Exception(String.format(EXCEPTION_NO_ARGUMENT, "finish"));
		}
	}

	@Override
	public Command generateCommand() throws Exception {
		int indexToFinish = getTaskIdFromString(commandBody, "finish");
		return new FinishCommand(indexToFinish);
	}

}
```
###### src\doordonote\commandfactory\HelpHandler.java
``` java

public class HelpHandler extends CommandHandler {

	protected HelpHandler(String commmandBody) {
		super(commmandBody);
	}

	@Override
	public Command generateCommand() {
		if (Util.isEmptyOrNull(commandBody)) {
			return new HelpCommand();
		} else {
			return new HelpCommand(commandBody);
		}
	}

}
```
###### src\doordonote\commandfactory\HomeHandler.java
``` java

public class HomeHandler extends CommandHandler {

	protected HomeHandler(String commmandBody) throws Exception {
		super(commmandBody);
		if (!Util.isEmptyOrNull(commmandBody)) {
			throw new Exception(String.format(EXCEPTION_EXCESS_ARGUMENTS, "home"));
		}
	}

	@Override
	public Command generateCommand() {
		return new HomeCommand();
	}

}
```
###### src\doordonote\commandfactory\ReadPathHandler.java
``` java

/**
 * Reads the storage file from the user specified path.
 * If no path is specified, returns the current file path that is being used.
 * 
 * @author yunpeng
 *
 */
public class ReadPathHandler extends CommandHandler {

	protected ReadPathHandler(String commandBody) {
		super(commandBody);
	}

	@Override
	public Command generateCommand() {		
		if (Util.isEmptyOrNull(commandBody)) {
			return new GetPathCommand();
		}
		return new ReadPathCommand(commandBody);
	}

}
```
###### src\doordonote\commandfactory\RedoHandler.java
``` java

public class RedoHandler extends CommandHandler {

	protected RedoHandler(String commmandBody) throws Exception {
		super(commmandBody);
		if (!Util.isEmptyOrNull(commandBody)) {
			throw new Exception(String.format(EXCEPTION_EXCESS_ARGUMENTS, "redo"));
		}
	}

	@Override
	public Command generateCommand() {
		return new RedoCommand();
	}

}
```
###### src\doordonote\commandfactory\RestoreHandler.java
``` java

public class RestoreHandler extends CommandHandler {

	protected RestoreHandler(String commandBody) throws Exception {
		super(commandBody);
		if (Util.isEmptyOrNull(commandBody)) {
			throw new Exception(String.format(EXCEPTION_NO_ARGUMENT, "restore"));
		}
	}

	@Override
	public Command generateCommand() throws Exception {
		int indexToRestore = getTaskIdFromString(commandBody, "restore");
		return new RestoreCommand(indexToRestore);
	}

}
```
###### src\doordonote\commandfactory\SetPathHandler.java
``` java

/**
 * Sets the path where the storage file should be saved in the local file system.
 * 
 * @author yunpeng
 *
 */
public class SetPathHandler extends CommandHandler {

	protected SetPathHandler(String commandBody) throws Exception {
		super(commandBody);
		
		if (Util.isEmptyOrNull(commandBody)) {
			throw new Exception(String.format(EXCEPTION_NO_ARGUMENT, "save"));
		}
	}

	@Override
	public Command generateCommand() {
		return new SetPathCommand(commandBody);
	}

}
```
###### src\doordonote\commandfactory\UndoHandler.java
``` java

public class UndoHandler extends CommandHandler {

	protected UndoHandler(String commmandBody) throws Exception {
		super(commmandBody);
		if (!Util.isEmptyOrNull(commandBody)) {
			throw new Exception(String.format(EXCEPTION_EXCESS_ARGUMENTS, "undo"));
		}
	}

	@Override
	public Command generateCommand() {
		return new UndoCommand();
	}

}
```
###### src\doordonote\commandfactory\UpdateHandler.java
``` java

public class UpdateHandler extends AbstractAddCommandHandler {
	protected UpdateHandler(String commandBody, DateParser dateParser) throws Exception {
		super(commandBody, dateParser, "update");
	}

		@Override
	public Command generateCommand() throws Exception {
		int indexToUpdate = getIndexToUpdate();
		String taskDescription = getTaskDescription();
		Date startDate = getStartDate();
		Date endDate = getEndDate();
		if (Util.isBlankString(taskDescription)) {
			return new UpdateCommand(indexToUpdate);
		} else {			
			return new UpdateCommand(indexToUpdate, taskDescription, startDate, endDate);
		}
	}
	
	@Override
	protected String getTaskDescription() throws Exception {
		return Util.removeFirstWord(super.getTaskDescription());		
	}
	
	protected int getIndexToUpdate() throws Exception {
		String taskIdString = Util.getFirstWord(commandBody);
		int indexToUpdate = getTaskIdFromString(taskIdString, "update");
		return indexToUpdate;
	}
	

}
```
###### src\doordonote\commandfactory\ViewHandler.java
``` java

public class ViewHandler extends CommandHandler {
	protected static final String EXCEPTION_INVALID_VIEW_ARGUMENT = "Do you mean 'view deleted' or 'view finished'?";

	protected ViewHandler(String commandBody) throws Exception {
		super(commandBody);
		if (Util.isEmptyOrNull(commandBody)) {
			throw new Exception(String.format(EXCEPTION_NO_ARGUMENT, "view"));
		}
		this.commandBody = commandBody.trim().toLowerCase();
	}

	@Override
	public Command generateCommand() throws Exception {
		if (commandBody.contains("del")) {
			return new ViewDeletedTaskCommand();
		} else if (commandBody.contains("fin")) {
			return new ViewFinishedTaskCommand();
		} else {
			throw new Exception(EXCEPTION_INVALID_VIEW_ARGUMENT);
		}
	}

}
```
###### src\doordonote\common\Util.java
``` java

public final class Util {

	private Util() {
		// TODO Auto-generated constructor stub
	}
	
	public static String removeFirstWord(String input) {
		return input.replaceFirst(getFirstWord(input), "").trim();
	}

	public static String getFirstWord(String input) {
		String commandTypeString = input.trim().split("\\s+")[0];
		return commandTypeString;
	}
	
	public static boolean isEmptyOrNull(String input) {
		return (input == null || input.trim().isEmpty());
	}
	
	
	public static boolean isBlankString(String input) {
		return input.trim().isEmpty();
	}
	
	public static String getDateString(Date input) {
		if (input == null) {
			return null;
		} else {
			DateFormat dateFormatter = new SimpleDateFormat("d MMM ''yy H:mm");
			return dateFormatter.format(input);
		}
	}
	
	
	/**
	 * @author A0131716M
	 *
	 */
	public static Task createTask(String description, Date startDate, Date endDate){
		Task task = null;

		if(description!=null && startDate==null && endDate==null){
			task = new FloatingTask(description);
		} else if(description!=null && startDate==null && endDate!=null){
			task = new DeadlineTask(description, endDate);
		} else if(description!=null && startDate!=null && endDate!=null){
			task = new EventTask(description, startDate, endDate);
		} else {
			assert (task != null):"Invalid Task parameters";
		}

		return task;
	}
}
```
###### src\doordonote\logic\CommandToController.java
``` java

public interface CommandToController {
	String add(String taskDescription, Date startDate, Date endDate) throws IOException, DuplicateTaskException;

	String delete(int taskId) throws Exception;

	String find(List<String> keywords) throws IOException;
	
	String finish(int taskId) throws IOException, Exception;
	
	String help();
	
	String help(String commandType);
	
	String redo() throws IOException;
	
	String undo() throws IOException;
	
	String update(int taskId, String taskDescription, Date startDate, Date endDate) throws Exception;
	
	String home() throws IOException;

	String restore(int taskId) throws IOException, Exception;

	String viewFinished() throws IOException;

	String viewDeleted() throws IOException;

	String getTaskStringById(int taskID) throws Exception;

	UIState getState();

	String find(Date startDate) throws IOException;

	String readFromFilePath(String pathName);

	String saveFileAt(String pathName);

	List<Task> getTaskList() throws IOException;

	String getCurrentFilePath();

}
```
###### src\doordonote\logic\Controller.java
``` java

public class Controller implements CommandToController {
	
	private static final String MESSAGE_HOME = "Displaying all unfinished task(s)";
	
	protected Storage storage = null;
	protected UIState stateObj = null;
	protected TaskFilter taskFilter = null;
	
	protected List<Task> userTaskList = null;
	
	protected Deque<UIState> undoStack = null;
	protected Stack<UIState> redoStack = null;
	
	
	/**
	 * 
	 * @throws IOException
	 */
	public Controller() throws IOException {
		this(StorageHandler.getInstance());
	}
	
	/**
	 * @param storage
	 * 
	 * Constructor used for injection dependency to replace Storage with a stub for testing
	 * @throws IOException 
	 */
	protected Controller(Storage storage) throws IOException {
		this.storage = storage;
		stateObj = new UIState();
		taskFilter = new TaskFilter(storage);
		undoStack = new LinkedList<UIState>();
		redoStack = new Stack<UIState>();
		userTaskList = new ArrayList<Task>();
		updateTaskList();
	}

	@Override
	public String add(String taskDescription, Date startDate, Date endDate) throws IOException, DuplicateTaskException {
		// Should have checked this in Command
		assert(!Util.isEmptyOrNull(taskDescription));
		
//		stateObj.clearTempState();
		List<Task> oldTaskList = userTaskList;
		
		Task taskToBeAdded = Util.createTask(taskDescription, startDate, endDate);
		
		String outputMsg;
		try {
			outputMsg = storage.add(taskToBeAdded);
		} catch (DuplicateTaskException e) {
			// TODO add a logger here
			throw e;
		}		
		
		
		
		if (stateObj.displayType != ListType.NORMAL) {
			stateObj.setDefault();
		} else {
			updateTaskList();
			List<Task> newTaskList = userTaskList;
			assert(newTaskList != null && oldTaskList != null);
			if (newTaskList.size() > oldTaskList.size()) {
				stateObj.clearTempState();				
			} else {
				stateObj.setDefault();
			}
		}
		stateObj.idNewTask = getNewTaskId(taskToBeAdded);
		return outputMsg;
	}

	@Override
	public String delete(int taskId) throws Exception {
//		stateObj.clearTempState();
		Task taskToDelete = getTask(taskId);
		String outputMsg = null;
		if (stateObj.displayType == ListType.DELETED) {
			outputMsg = storage.remove(taskToDelete);
		} else {
			outputMsg = storage.delete(taskToDelete);

		}
		return outputMsg;
	}
	
	protected Task getTask(int taskId) throws Exception {
		if (taskId > userTaskList.size()) {
			throw new Exception("Invalid taskID!");
		}
		return userTaskList.get(taskId - 1);
	}
	

	@Override
	public String find(List<String> keywords) throws IOException {
//		stateObj.clearTempState();
		stateObj.filterList = keywords;
		stateObj.filterDate = null;
		
		 updateTaskList();
		
		if (!userTaskList.isEmpty()) {
			return userTaskList.size() + " task(s) found";
		} else {
			return "No task found!";
		}
	}

	@Override
	public String finish(int taskId) throws Exception {
//		stateObj.clearTempState();
		
		if (stateObj.displayType == ListType.FINISHED) {
			throw new Exception("Task is already finished!");
		}

		Task taskToFinish = getTask(taskId);
		String outputMsg = storage.finish(taskToFinish);
    	return outputMsg;
	}
	
	@Override
	public UIState getState() {
		UIState copyOfUIState = new UIState(stateObj);
//		stateObj.clearTempState();
		return copyOfUIState;
	}

	@Override
	public String help() {
//		stateObj.clearTempState();
		stateObj.helpBox = "help";
		return "Displaying help";
	}

	@Override
	public String help(String commandType) {
//		stateObj.clearTempState();

		stateObj.helpBox = commandType;
		return "Displaying help";
	}

	@Override
	public String redo() throws IOException {
		stateObj.setDefault();
		String outputMsg = storage.redo();
		return outputMsg;
	}

	@Override
	public String undo() throws IOException {
		stateObj.setDefault();
		String outputMsg = storage.undo();
		return outputMsg;
	}

	@Override
	public String update(int taskId, String taskDescription, Date startDate, Date endDate) throws Exception {
//		stateObj.clearTempState();

		if (stateObj.displayType == ListType.FINISHED || stateObj.displayType == ListType.DELETED) {
			throw new Exception("Cannot update deleted/ finished tasks!");
		}
		
		Task taskToUpdate = getTask(taskId);
		Task newTask = Util.createTask(taskDescription, startDate, endDate);
		String outputMsg = storage.update(taskToUpdate, newTask);

		updateTaskList();
		
		stateObj.idNewTask = getNewTaskId(newTask);
		stateObj.inputBox = "";
		return outputMsg;
	}
	
	@Override
	public String home() throws IOException {
		stateObj.setDefault();
		return MESSAGE_HOME;
	}


	@Override
	public String restore(int taskId) throws Exception {
//		stateObj.clearTempState();

		if (stateObj.displayType == ListType.NORMAL) {
			throw new Exception("Cannot restore an undeleted/ unfinished task!");
		}
		
		Task taskToRestore = getTask(taskId);
		String outputMsg = storage.restore(taskToRestore);
		return outputMsg;
	}


	@Override
	public String viewFinished() throws IOException {
		stateObj.setDefault();
		stateObj.displayType = ListType.FINISHED;
		return "Displaying finished tasks";
	}


	@Override
	public String viewDeleted() throws IOException {
		stateObj.setDefault();
		stateObj.displayType = ListType.DELETED;
		return "Displaying deleted tasks";
	}
	
	@Override
	public String getTaskStringById(int taskId) throws Exception {
//		stateObj.clearTempState();
		Task taskToBeUpdated = getTask(taskId);
		stateObj.inputBox = getTaskToBeUpdated(taskToBeUpdated, taskId);
		stateObj.idNewTask = -1;
		return "Task " + taskId + " found!";
	}


	protected String getTaskToBeUpdated(Task taskToBeUpdated, int taskId) {
		String taskDescription = taskToBeUpdated.getDescription();
		Date startDate = taskToBeUpdated.getStartDate();
		Date endDate = taskToBeUpdated.getEndDate();
		String startDateString = Util.getDateString(startDate);
		String endDateString = Util.getDateString(endDate);

		String taskString = null;
		if (endDate == null) {
			taskString = taskDescription;
		} else if (startDate == null) {
			taskString = taskDescription + " by " + endDateString;
		} else {
			taskString = taskDescription + " from " + startDateString + " to " + endDateString;
		}
		return "update " + taskId + " " + taskString;
	}
	
	/**
	 * @param oldTaskList
	 * @return taskId of new task added
	 * @throws IOException 
	 */
	protected int getNewTaskId(Task newTask) throws IOException {
		updateTaskList();
		return userTaskList.indexOf(newTask);
	}

	private void updateTaskList() throws IOException {
		userTaskList = taskFilter.getUserTaskList(stateObj);
	}
	
	@Override
	public List<Task> getTaskList() throws IOException {
		updateTaskList();
		return userTaskList; 
	}
	
	@Override
	public String find(Date startDate) throws IOException {
		assert(startDate != null);
//		stateObj.clearTempState();
		stateObj.filterDate = startDate;
		stateObj.filterList = null;
		return "Displaying from " + Util.getDateString(startDate);
	}

	@Override
	public String readFromFilePath(String pathName) {
//		stateObj.clearTempState();
		assert(pathName != null);
		String feedback = storage.get(pathName);
		stateObj.setDefault();
		return feedback;
	}

	@Override
	public String saveFileAt(String pathName) {
//		stateObj.clearTempState();
		assert(pathName != null);
		String feedback = storage.path(pathName);
		stateObj.setDefault();
		return feedback;
	}

	@Override
	public String getCurrentFilePath() {
//		stateObj.clearTempState();
		return "Currently reading from: " + storage.getCurrentFilePath();
	}
}
```
###### src\doordonote\logic\Logic.java
``` java

package doordonote.logic;

import java.io.IOException;
import java.util.List;

import doordonote.command.Command;
import doordonote.commandfactory.CommandFactory;
import doordonote.common.Task;

```
###### src\doordonote\logic\Logic.java
``` java

public class Logic implements UIToLogic {
	protected CommandFactory cmdFactory = null;
	protected CommandToController controller = null;
	
	public Logic() throws IOException {
		cmdFactory = new CommandFactory();
		controller = new Controller();
	}
	
	@Override
	public String parseAndExecuteCommand(String userInput) throws Exception {
		Command cmd = cmdFactory.parse(userInput);
		return cmd.execute(controller);
	}
	
	@Override
	public UIState getState() {
		return controller.getState();
	}

	@Override
	public List<Task> getTasks() {
		List<Task> taskList = null;
		try {
			taskList = controller.getTaskList();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return taskList;
	}
	

}
```
###### src\doordonote\logic\TaskFilter.java
``` java

/**
 * {@code TaskFilter} filters the tasks visible to users based on 
 * the UIState object.
 * 
 * @author yunpeng
 *
 */
public class TaskFilter {
	
	protected Storage storage = null;
	protected ArrayList<Task> fullTaskList = null;
	
	protected TaskFilter(Storage storage) throws IOException {
		this.storage = storage;
//		try {
		fullTaskList = storage.readTasks();
//		} catch (Exception e) {
//			// Creates an empty task list if there is error reading the storage file
//			fullTaskList = new ArrayList<Task>();
//			throw new IOException("Error opening storage file. Please use "
//					+ "readFile to read from another storage file");
//		}
	}
	
//	protected void setStorage(Storage storage) {
//		this.storage = storage;
//	}
	
	public List<Task> getUserTaskList(UIState stateObj) throws IOException {
		fullTaskList = storage.readTasks();
		assert (fullTaskList != null);
		List<Task> userTaskList = filterTaskByDisplayType(stateObj);
		return filterByDateAndKeywords(stateObj, userTaskList);
	}

	private List<Task> filterByDateAndKeywords(UIState stateObj, List<Task> userTaskList) {
		if (stateObj.filterDate != null) {
			return filterByDate(userTaskList, stateObj.filterDate);
		} else if (stateObj.filterList != null) {
			return filterByKeywords(userTaskList, stateObj.filterList);
		} else {
			return userTaskList;
		}
	}
	
	private List<Task> filterTaskByDisplayType(UIState stateObj) throws IOException {
		List<Task> userTaskList;
		switch (stateObj.displayType) {
		case DELETED :
			userTaskList = getDeletedTasks();
			break;
		case FINISHED :
			userTaskList = getFinishedTasks();
			break;
		case NORMAL :
			// fallthrough
		default :
			userTaskList = getUnfinishedTasks();
		}
		return userTaskList;
	}
	
	protected List<Task> filterByDate(List<Task> unfilteredUserTaskList, Date startDate) {
		List<Task> userTaskList = new ArrayList<Task>();
		for (Task task : unfilteredUserTaskList) {
			if (task.getEndDate() != null && task.getEndDate().after(startDate)) {
				userTaskList.add(task);
			}
		}

		return userTaskList;		
	}

	protected List<Task> filterByKeywords(List<Task> unfilteredUserTaskList, List<String> filterList) {
		List<Task> tempList = null;
		List<Task> userTaskList = unfilteredUserTaskList;
		for (String keyword : filterList) {
			tempList = new ArrayList<Task>();
			for (Task task : userTaskList) {
				if (task.getDescription().toLowerCase().contains(keyword.toLowerCase())) {
					tempList.add(task);
				}
			}
			userTaskList = tempList;
		}
		return userTaskList;
	}

	private List<Task> getUnfinishedTasks() throws IOException {
		return storage.readTasks();
	}

	private List<Task> getFinishedTasks() throws IOException {
		return storage.readDoneTasks();
	}

	private List<Task> getDeletedTasks() throws IOException {
		return storage.readDeletedTasks();
	}
	
}
	




```
###### src\doordonote\logic\UIState.java
``` java

public class UIState {
	
	// Type of display
	public enum ListType {
	    DELETED, FINISHED, NORMAL
	}
	
	
	// Fills the user inputBox with this String.
	// Only used by the update method in Controller
	protected String inputBox = null;
	
	// Determines the type of helpBox to display
	protected String helpBox = null;
	
	// Determines the type of Tasks to display
	protected ListType displayType = null;
	
	// Stores the id of a new task. UI will use this id 
	// to highlight newly added tasks
	protected int idNewTask = -1;
	
	// A list of words used to filter the task. Set by the find
	// find method in controller
	protected List<String> filterList = null;
	
	// Filters and displays the list of tasks that ends after
	// this Date
	protected Date filterDate = null;
	
	public UIState() {
		setDefault();
	}
	
	/**
	 * Used to clone a UIState object
	 * 
	 * @param 	other
	 * 			The UIState object to be cloned.
	 */
	public UIState(UIState other) {
		inputBox = other.inputBox;
		displayType = other.displayType;
		helpBox = other.helpBox;
		idNewTask = other.idNewTask;
		filterList = other.filterList;
		filterDate = other.filterDate;
	}
	
	public int getIdNewTask() {
		return idNewTask;
	}

	public ListType getDisplayType() {
		return displayType;
	}

	public String getInputBox() {
		return inputBox;
	}
	
	public String getHelpBox() {
		return helpBox;
	}
	
	/**
	 * Gets a suitable title based on the current state
	 * of the UIState 
	 * 
	 * @return the title that should be displayed
	 */
	public String getTitle() {
		String title = "";
		title = getTitleBasedOnDisplayType();
		if (filterDate != null) {
			return getTitleForFilterDate(title);
		} else if (filterList != null && !filterList.isEmpty()) {
			return getTitleForFilterList(title);
		} else {
			return title;
		}
	}

	private String getTitleBasedOnDisplayType() {
		String title;
		switch (displayType) {
		case FINISHED :
			title = "Finished Tasks";
			break;
		case DELETED :
			title = "Deleted Tasks";
			break;
		case NORMAL :
			// fall through
		default :
			title = "Home";
		}
		return title;
	}

	private String getTitleForFilterDate(String title) {
		title += "- Tasks that ends after: ";
		title += Util.getDateString(filterDate);
		return title;
	}

	private String getTitleForFilterList(String title) {
		title += "- Filter by: ";
		for (String word : filterList) {
			title += word + ", ";
		}
		return title;
	}

	
	/**
	 * Removes states that should not persist
	 */
	protected void clearTempState() {
		inputBox = "";
		helpBox = null;
		idNewTask = -1;
	}
	
	/**
	 * Sets the default state
	 */
	protected void setDefault() {
		inputBox = "";
		displayType = ListType.NORMAL;
		helpBox = null;
		idNewTask = -1;
		filterList = null;
		filterDate = null;
	}

	/* 
	 * equals() is used only in testing
	 */
	public boolean equals(Object other) {
	    if (other == null) {
	        return false;
	    }
	    if (other == this) {
	    	return true;
	    }

        if (other instanceof UIState) {
        	UIState otherUIState = (UIState)other;
        	if (this.inputBox == otherUIState.inputBox && 
        		this.helpBox == otherUIState.helpBox &&
        		this.displayType == otherUIState.displayType &&
	        	this.idNewTask == otherUIState.idNewTask &&
	        	this.filterList == otherUIState.filterList &&
	        	this.filterDate == otherUIState.filterDate) {
        		return true;
        	}
        }
        return false;
	}
	
	/*
	 * hashCode method is implemented only to be consistent with the equals() method
	 * For using UIState class in any hash methods (e.g. storing it in a Hashmap),
	 * a better implementation of hashCode should be used.
	 */
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((inputBox == null) ? 0 : inputBox.hashCode());
		result = prime * result + ((helpBox == null) ? 0 : helpBox.hashCode());
		result = prime * result + idNewTask;
		result = prime * result + ((filterList == null) ? 0 : filterList.hashCode());
		result = prime * result + ((filterDate == null) ? 0 : filterDate.hashCode());
		return result;
	}
}
	
```
###### src\doordonote\logic\UIToLogic.java
``` java

public interface UIToLogic {
	/** 
	 * Gets a list of Tasks filtered based on the UIState object.
	 * Tasks in the list should be sorted.
	 * 
	 * @return A sorted {@code List<Task}
	 */
	List<Task> getTasks();
	
	/**
	 * @param 	userInput
	 * 			User input commands to be parsed and interpreted.
	 * @return	Feedback message for users to know what has been executed.
	 * @throws 	Exception
	 * 			Exception contains error messages to inform users that their
	 * 			input is not executed properly.
	 */
	String parseAndExecuteCommand(String userInput) throws Exception;
	UIState getState();
}
```
###### test\doordonote\commandfactory\CommandFactoryTest.java
``` java

package doordonote.commandfactory;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

public class CommandFactoryTest {
//	private CommandFactory cmdFactory = new CommandFactory();

	@Test
	public void getCommandTypeTest() {
		assertEquals("getCommandType should be case insensitive", 
					 "add", 
					 CommandFactory.getCommandType("AdD list of statements"));
		
		assertEquals("getCommandType should be robust to leading spaces",
				 	 "test", 
				 	 CommandFactory.getCommandType("  test  list of "));
		assertEquals("getCommandType should be return empty string for blank strings",
			 	 	 "", 
			 	 	 CommandFactory.getCommandType("   "));	
	}
	
	@Test
	public void parseTest() {
		
	}

}
```
###### test\doordonote\commandfactory\DateParserTest.java
``` java

package doordonote.commandfactory;

import static org.junit.Assert.assertEquals;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.joda.time.DateTime;
import org.junit.Test;

public class DateParserTest {
	
	private DateParser parser = new DateParser();

	
	@Test
	public void parseAndGetDateListTest() {
		DateTime dt1 = new DateTime(2013, 1, 15, 8, 0, 0, 0);
		DateTime dt2 = new DateTime(2015, 3, 30, 8, 0, 0, 0);
	    Date jdkDate1 = dt1.toDate();
	    Date jdkDate2 = dt2.toDate();
	    List<Date> createdDateList = new ArrayList<Date>();
	    createdDateList.add(jdkDate1);
	    createdDateList.add(jdkDate2);
	    List<Date> parsedDateList = parser.parseAndGetDateList("from 15 jan 2013 to 30 march  8");
        
	    assertEquals("Parser should get list of 2 dates", createdDateList, parsedDateList);
	    
	    createdDateList.remove(1);
	    //check that parser only parse one date when no connecting words like "to" is used
	    assertEquals("Parser should get only one valid date without 'to'", 
	    			 createdDateList, 
	    			 parser.parseAndGetDateList("from 15 jan 2013 30 march  7.45"));
	    assertEquals("Parser should return empty if no dates are found", 
	    			 new ArrayList<Date>(), 
	    			 parser.parseAndGetDateList("do research on database"));


	}
	
	@Test
	public void parseTest() {
		// Creates DateTime object with information like year, month,
        // day, hour, minute, second and milliseconds
		DateTime dt1 = new DateTime(2015, 11, 24, 8, 0, 0, 0);
	    Date jdkDate1 = dt1.toDate();
	    
		DateTime dt2 = new DateTime(2015, 4, 8, 12, 0, 0, 0);
	    Date jdkDate2 = dt2.toDate();
        assertEquals("Parser should return default time at 8am", jdkDate1, parser.parse("nov 24"));
        assertEquals("Parser should be able to deal with leading/ trailing space", 
        			 jdkDate2, 
        			 parser.parse("april 8   12pm"));
        assertEquals("Parser should be able to take empty strings", null, parser.parse(""));
	}

}
```
###### test\doordonote\logic\ControllerTest.java
``` java

package doordonote.logic;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.joda.time.DateTime;
import org.junit.Before;
import org.junit.Test;

import doordonote.logic.UIState.ListType;
import doordonote.storage.DuplicateTaskException;
import doordonote.storage.Storage;

public class ControllerTest {
	private Controller controller = null;
	private Storage storage = null;
	
	@Before
	public void setUp() throws Exception {
		
		// Adds 3 tasks to StorageStub obj
		String description1 = "Task 1";
		DateTime startDt1 = new DateTime(2015, 11, 30, 8, 0, 0, 0);
		DateTime endDt1 = new DateTime(2015, 11, 30, 8, 0, 0, 0);

		String description2 = "Task 2";
		DateTime endDt2 = new DateTime(2015, 11, 30, 8, 0, 0, 0);
		
		String description3 = "Task 3";
		
		storage = new StorageStub();
		storage.add(description1, startDt1.toDate(), endDt1.toDate());
		storage.add(description2, null, endDt2.toDate());
		storage.add(description3, null, null);
		
		controller = new Controller(storage);
	}
	
	@Test
	public void addTest() throws IOException, DuplicateTaskException {
		String description = "task to be added";
		// Creates DateTime object with information like year, month,
        // day, hour, minute, second and milliseconds
		DateTime startDt = new DateTime(2015, 11, 30, 8, 0, 0, 0);
		DateTime endDt = new DateTime(2015, 11, 30, 8, 0, 0, 0);
		String feedBack = null;

		controller.stateObj.displayType = ListType.DELETED;
		UIState testStateObj1 = new UIState();
		testStateObj1.idNewTask = 3;
		
		feedBack = controller.add(description, 
								  startDt.toDate(), 
								  endDt.toDate());

		
		// Testing if add is called and if ListType is set to Normal
		assertEquals("Test if storage.add() is called", "Add is called", feedBack);
		assertEquals("Test if UISTATE is updated correctly", testStateObj1, controller.getState());
		
		UIState testStateObj2 = new UIState();
		List<String> filterList = new ArrayList<String>();
		filterList.add("3");
		testStateObj2.filterList = filterList;
		testStateObj2.idNewTask = 1;
		controller.stateObj.filterList = filterList;
		controller.add("test task 3", null, null);
		
		
		// Testing if add maintains the same filterList if task added
		// can be seen from current list
		assertEquals("Test if UISTATE maintains the filter criteria", testStateObj2, controller.getState());
	}
	
	@Test
	public void deleteTest() throws Exception {
		String feedBack1 = controller.delete(1);
		UIState testStateObj1 = new UIState();
		assertEquals("Test if storage.delete() is called", "Delete is called", feedBack1);
		assertEquals("Test if UISTATE is updated correctly", testStateObj1, controller.getState());

		controller.stateObj.displayType = ListType.DELETED;
		String feedBack2 = controller.delete(1);
		UIState testStateObj2 = new UIState();
		testStateObj2.displayType = ListType.DELETED;
		assertEquals("Test if storage.remove() is called", "Remove is called", feedBack2);
		assertEquals("Test if UISTATE is updated correctly", testStateObj2, controller.getState());
		
		
	}
	
	@Test
	public void displayDeletedTest() throws IOException {
		UIState testStateObj = new UIState();
		testStateObj.displayType = ListType.DELETED;
		controller.viewDeleted();
		assertEquals("Test if UIState is updated correctly", 
			 	 	 testStateObj, 
			 	 	 controller.getState());
	}
	
	@Test
	public void displayFinishedTest() throws IOException {
		UIState testStateObj = new UIState();
		testStateObj.displayType = ListType.FINISHED;
		controller.viewFinished();
		assertEquals("Test if UIState is updated correctly", 
			 	 	 testStateObj, 
			 	 	 controller.getState());
	}
	
	@Test
	public void findDateTest() throws IOException {
		DateTime startDt = new DateTime(2015, 9, 30, 0, 0, 0, 0);
		Date startDate = startDt.toDate();
		controller.find(startDate);
		UIState testStateObj = new UIState();
		testStateObj.filterDate = startDate;
		
		
		assertEquals("Test if UIState is updated correctly", 
				 	 testStateObj, 
				 	 controller.getState());
	}
	
	@Test
	public void finishTest() throws Exception {
		String feedBack1 = controller.finish(1);
		UIState testStateObj1 = new UIState();
		
		assertEquals("Test if storage.finish() is called", "Finish is called", feedBack1);
		assertEquals("Test if UISTATE is updated correctly", testStateObj1, controller.getState());
		
		controller.stateObj.displayType = ListType.FINISHED;
		try {
			controller.finish(1);
			fail("Exception should have been thrown");
		} catch (Exception e) {
			assertEquals("Test if exception displays the right msg", 
						 "Task is already finished!", 
						 e.getMessage());
		}

	}
	
	@Test
	public void helpTest() {
		controller.help();
		
		controller.help("test");
		controller.help("add");
	}
	
	@Test
	public void homeTest() throws IOException {
		controller.viewDeleted(); // Change the display type
		String homeMsg = controller.home();
		UIState testStateObj = new UIState();
		
		assertEquals("Test if home() return msg is correct", 
					 "Displaying all unfinished task(s)", 
					 homeMsg);
		assertEquals("Test if UIState is updated correctly", 
					 testStateObj, 
					 controller.getState());
	}
	
//	@Test
//	public void redoTest() {
//		fail("Not yet implemented");
//	}
//	
//	@Test
//	public void restoreTest() {
//		fail("Not yet implemented");
//	}
//
//	
//	@Test
//	public void undoTest() {
//		fail("Not yet implemented");
//	}
//	
//	@Test
//	public void updateTest() {
//		fail("Not yet implemented");
//	}
//	
//	@Test
//	public void pathTest() {
//		fail("Not yet implemented");
//	}
//	
//	@Test
//	public void getTest() {
//		fail("Not yet implemented");
//	}

}
```
###### test\doordonote\logic\StorageStub.java
``` java

package doordonote.logic;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;

import doordonote.common.Task;
import doordonote.common.Util;
import doordonote.storage.Storage;

public class StorageStub implements Storage {
	private ArrayList<Task> taskList = null;
	
	public StorageStub() {
		 taskList = new ArrayList<Task>();
	}
	
	@Override
	public String path(String location) {
		return "Path is called";
	}

	@Override
	public String get(String location) {
		return "Get is called";
	}

	@Override
	public String add(Task task) {
		taskList.add(task);
		return "Add is called";
	}

	@Override
	public String add(String description, Date startDate, Date endDate) {
		Task task = Util.createTask(description, startDate, endDate);
		return add(task);
	}

	@Override
	public String update(Task taskToUpdate, String description, Date startDate, Date endDate) {
		Task task = Util.createTask(description, startDate, endDate);
		return update(taskToUpdate,task);
	}

	@Override
	public String update(Task oldTask, Task newTask) {
		taskList.remove(oldTask);
		taskList.add(newTask);
		return "Update is called";
	}

	@Override
	public String delete(Task taskToDelete) {
		taskList.remove(taskToDelete);
;		return "Delete is called";
	}

	@Override
	public String remove(Task taskToRemove) throws IOException {
		taskList.remove(taskToRemove);
;		return "Remove is called";
	}

	@Override
	public ArrayList<Task> readTasks() throws IOException {
		return taskList;
	}

	@Override
	public String undo() {
		return "Undo is called";
	}

	@Override
	public String redo() {
		return "Redo is called";
	}

	@Override
	public String restore(Task task) throws IOException {
		return "Restore is called";
	}

	@Override
	public String finish(Task task) throws IOException {
		return "Finish is called";
	}

	
	// Not used
	@Override
	public String notFinish(Task task) throws IOException {
		// TODO Auto-generated method stub
		return null;
	}
	

	@Override
	public ArrayList<Task> readDeletedTasks() throws IOException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public ArrayList<Task> readDoneTasks() throws IOException {
		// TODO Auto-generated method stub
		return null;
	}
	
	@Override
	public String clear() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String getCurrentFilePath() {
		// TODO Auto-generated method stub
		return null;
	}

}
```
